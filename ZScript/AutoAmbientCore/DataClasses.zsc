class AutoAmbientSoundDefinition {
	String name;
	Sound snd;
	EAutoAmbientSoundModes sndMode;
	double sndVolume, sndAttenuation;
	uint minDelay, maxDelay;

	//double minRadius, minHeight;

	//Array<AutoAmbientGroup> groups;

	static AutoAmbientSoundDefinition Create( String initName, Sound initSnd, EAutoAmbientSoundModes initMode, double initVolume, double initAttn, uint initMinDelay, uint initMaxDelay ) {
		AutoAmbientSoundDefinition newDef = new( 'AutoAmbientSoundDefinition' );

		newDef.name = initName;
		newDef.snd = initSnd;
		newDef.sndMode = initMode;
		newDef.sndVolume = initVolume;
		newDef.sndAttenuation = initAttn;
		newDef.minDelay = initMinDelay;
		newDef.maxDelay = initMaxDelay;

		//newDef.minRadius = newDef.minHeight = 0.0;

		return newDef;
	}
} // of class AutoAmbientSoundDefinition {}


class AutoAmbientTextureParameter {
	const defaultStart = -50.0;
	const defaultOffset = -100.0;

	vector2 start, offset, spreading;
	double chance;
	String name;

	static AutoAmbientTextureParameter Create( String paramname, vector2 initStartOffset, vector2 initOffset, vector2 initSpreading, double initChance ) {
		AutoAmbientTextureParameter newDef = new( 'AutoAmbientTextureParameter' );

		// To prevent an infinite loop in actors spawning.
		if ( initOffset.x >= 0 && initOffset.x < 1.0 ) {
			initOffset.x = defaultOffset;
			// Temporal solution. And it seems like it isn't works...
			console.printf( "AutoAmbientTextureParameter::Create(). Warning: offset X in texture parameter \"" .. paramname .. "\" is too small (" .. initOffset.x .. "), setting to the default." );
		}
		if ( initOffset.y >= 0 && initOffset.y < 1.0 ) {
			initOffset.y = defaultOffset;
			console.printf( "AutoAmbientTextureParameter::Create(). Warning: offset Y in texture parameter \"" .. paramname .. "\" is too small (" .. initOffset.y .. "), setting to the default." );
		}

		newDef.name = paramname;
		newDef.start = initStartOffset;
		newDef.offset = initOffset;
		newDef.spreading = initSpreading;
		newDef.chance = ( initChance >= 0.0 && initChance <= 1.0 )? initChance : 1.0;

		return newDef;
	}

	// To enforce AutoAmbientTexture to recalculate offsets based on size.
	AutoAmbientTextureParameter Copy( void ) const {
		AutoAmbientTextureParameter copiedDef = new( 'AutoAmbientTextureParameter' );

		copiedDef.name = name;
		copiedDef.start = start;
		copiedDef.offset = offset;
		copiedDef.spreading = spreading;
		copiedDef.chance = chance;

		return copiedDef;
	}
} // of class AutoAmbientTextureParameter {}


class AutoAmbientTexture {
	TextureID id;
	vector2 size; // Texture precalculated size.

	bool invalidFlag;

	Array<AutoAmbientGroup> groups;
	Array<AutoAmbientTextureParameter> groupparams;

	EAutoAmbientLinesCheckFlags linesCheckFlags;
	double sameLineDistSpawnChance, otherLineDistSpawnChance; // Chance to spawn closer than the group mindistance.


	static AutoAmbientTexture Create( String textureName ) {
		AutoAmbientTexture newTex = NULL;
		TextureID addeeTexID = TexMan.CheckForTexture( textureName, TexMan.Type_Wall, TexMan.DontCreate );

		if ( TexMan.GetName( addeeTexID ) != "" ) {
			newTex = new( 'AutoAmbientTexture' );

			newTex.id = addeeTexID;
			newTex.size = TexMan.GetScaledSize( addeeTexID );
			newTex.linesCheckFlags = AALCF_Default;
			newTex.invalidFlag = false;
			newTex.sameLineDistSpawnChance = newTex.otherLineDistSpawnChance = 0.0;
		}

		return newTex;
	} // of static AutoAmbientTexture Create( String textureName ) {}

	static AutoAmbientTextureWithMaps CreateTemporalWithMaps( void ) {
		AutoAmbientTextureWithMaps newTex = new( 'AutoAmbientTextureWithMaps' );

		newTex.linesCheckFlags = AALCF_Default;
		newTex.restrictDefaultTextures = false;

		return newTex;
	} // of static AutoAmbientTextureWithMaps CreateTemporalBase( void ) {}


	void AddGroupParam( AutoAmbientGroup group, AutoAmbientTextureParameter param ) {
		if ( group && param ) {
			groups.Push( group );
			groupparams.Push( param );

			if ( size.length() > 0 ) {
				if ( param.start.x < 0.0 )
					param.start.x = size.x * -param.start.x / 100.0;
				if ( param.start.y < 0.0 )
					param.start.y = size.y * -param.start.y / 100.0;

				if ( param.offset.x <= 0.0 )
					param.offset.x = size.x * -param.offset.x / 100.0;
				if ( param.offset.y <= 0.0 )
					param.offset.y = size.y * -param.offset.y / 100.0;

				if ( param.spreading.x <= 0.0 )
					param.spreading.x = size.x * -param.spreading.x / 100.0;
				if ( param.spreading.y <= 0.0 )
					param.spreading.y = size.y * -param.spreading.y / 100.0;
			}
		} else {
			invalidFlag = true;
		}
	} // of void AddGroupParam( AutoAmbientGroup group, AutoAmbientTextureParameter param ) {}

	// By default start point is in the centre of the texture and
	//offset is a one texture size (for both X and Y):
	void AddGroup( AutoAmbientGroup group, vector2 xy = ( AutoAmbientTextureParameter.defaultStart, AutoAmbientTextureParameter.defaultStart ) ) {
		// It's real to use same names for different texture parameters... At least, now.

		AddGroupParam( group,
			AutoAmbientTextureParameter.Create(
					String.Format( "#%3.1f/%3.1f#%08x", xy.x, xy.y, Random( 0, 0x7FFFFFFF ) ),
					xy,
					( AutoAmbientTextureParameter.defaultOffset, AutoAmbientTextureParameter.defaultOffset ),
					( 0, 0 ), 1.0
			)
		);
	}

	bool Validate( void ) {
		return ( id && size.Length() && groups.Size() && !invalidFlag );
	}
} // of class AutoAmbientTexture {}

class AutoAmbientTextureWithMaps: AutoAmbientTexture {
	Array<String> mapnames;
	Array<String> maphashes;

	bool restrictDefaultTextures;
} // of class AutoAmbientTextureWithMaps: AutoAmbientTexture {}



class AutoAmbientMapsData {
	String mapname, maphash;
	Array<AutoAmbientTexture> textures;

	// Add textures over the defaults ("false") or set them from zero ("true").
	bool restrictDefaultTextures;
} // of class AutoAmbientMapsData {}

class AutoAmbientMapSet play {
	Array<AutoAmbientMapsData> maps;
	int prevMapIndex;

	static AutoAmbientMapSet Create( void ) {
		return new( 'AutoAmbientMapSet' );
	}

	// Searches the map in the internal array:
	int FindMap( String mapname = "", String maphash = "" ) {
		int foundMap = -1;
		uint mapsSize = maps.Size();

		if ( mapsSize != 0 ) {
			if ( prevMapIndex < mapsSize ) {
				if ( prevMapIndex != -1 && ( ( mapname != "" && maps[ prevMapIndex ].mapname ~== mapname ) || ( maphash != "" && maps[ prevMapIndex ].maphash ~== maphash ) ) ) {
					foundMap = prevMapIndex;
				} else {
					for ( uint i = 0; i < mapsSize; i++ ) {
						if ( ( mapname != "" && maps[ i ].mapname ~== mapname ) || ( maphash != "" && maps[ i ].maphash ~== maphash ) ) {
							foundMap = prevMapIndex = i;
							break;
						}
					}
				}
			} else {
				AutoAmbientLogger.Get().Log( LL_Emergency, GetClassName() .. "::FindMap(). Cached last map index (" .. prevMapIndex .. ") is greater than array size (" .. mapsSize .. ")." );
			}

		}

		return foundMap;
	}

	void AddToMap( AutoAmbientTexture texture, String mapname = "", String maphash = "" ) {
		if ( texture != NULL && texture.id ) {
			if ( mapname != "" || maphash != "" ) {
				int mapindex = FindMap( mapname, maphash );

				if ( mapindex == -1 ) {
					// Creating a new map data record if it isn't exists.
					AutoAmbientLogger.Get().Log( LL_Debug, GetClassName() .. "::AddToMap(). Creating new map named \"" .. mapname .. "\"/hashed \"" .. maphash .. "\" for texture \"" .. texture.id .. "\"." );

					AutoAmbientMapsData newmapdata = new( 'AutoAmbientMapsData' );
					newmapdata.mapname = mapname;
					newmapdata.maphash = maphash;
					prevMapIndex = mapindex = maps.Push( newmapdata );
				}

				maps[ mapindex ].textures.Push( texture );
			} else {
				AutoAmbientLogger.Get().Log( LL_Emergency, GetClassName() .. "::AddToMap(). Both map name and map hash parameters are omitted (texture \"" .. texture.id .. "\")." );
			}
		} else {
			AutoAmbientLogger.Get().Log( LL_Emergency, GetClassName() .. "::AddToMap(). Wrong texture <" .. texture .. "> (method args: mapname \"" .. mapname .. "\", maphash \"" .. maphash .. "\"." );
		}
	}

	uint Size( void ) {
		return maps.Size();
	}
} // of class AutoAmbientMapSet {}
