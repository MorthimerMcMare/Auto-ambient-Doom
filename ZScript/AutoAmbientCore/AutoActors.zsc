
class AutoAmbientGroup play {
	// Minimal length of a cell side length (will be clamped to this value).
	const minGridCellSideLength = 96.0;

	// Maximal length of an array's each dimension (will be scaled to fit to).
	const maxGridLength = 31; // Note that real value will be increased by 1.

	// Maximal "Spawned" array size to use usual, non-9-cell-based algorithm.
	const wholeListAlgorithmMaxSpawnedSize = 16;


	AutoAmbientGlobalHandler g;
	AutoAmbientLogger logger;

	String name;
	Array< class<Actor> > classes;
	Array<AutoAmbientSoundDefinition> autoclasses;
	double actorsDistance; // Also side length of the one square (one cell).

	AutoAmbientSoundActorConfiguration autoclassConfig;

	// All spawned on the level auto actors for this group:
	AutoAmbientListSpawnedKeeper spawned; // Often it's more fast to check for some actor in the whole list.
	Array<AutoAmbientSpawnedGridCellX> gridX;

	// Temporal array which contain all positions to be moved to the "spawned[]"
	//array on the next iteration. Defined for the quick same side distance
	//checks.
	AutoAmbientListSpawnedKeeper spawnedOnSide;


	double topLevelBound, leftLevelBound;

	int gridSizeX, gridSizeY;
	double cellSideSize;

	clearscope int GetGridXOffset( double posx ) const {
		return int( ( posx - leftLevelBound ) / cellSideSize );
	}

	clearscope int GetGridYOffset( double posy ) const {
		return int( ( topLevelBound - posy ) / cellSideSize );
	}


	void AddToGrid( Actor what ) {
		gridX[ GetGridXOffset( what.pos.x ) ].y[ GetGridYOffset( what.pos.y ) ].AppendSpawnedActor( what );
	}

	// "true" if there's other actors nearby.
	bool CheckForCloseNeighbours( vector3 pos, bool useDistMultipl, double lineDistSpawnChance ) {
		if ( !spawned || spawned.Empty() )
			return false;

		// Using fastest locating method (whole sequence/nearest grid cells):
		if ( !GridCreated() || spawned.Size() < wholeListAlgorithmMaxSpawnedSize ) {
			//console.printf( "Whole sequence algorithm." );
			return checkSpawnDistance( pos, spawned, useDistMultipl, lineDistSpawnChance );
		} else {
			int x = GetGridXOffset( pos.x );
			int y = GetGridYOffset( pos.y );

			//console.printf( "Group " .. name .. " ::CheckForCloseNeighbours(). x " .. x .. ", y " .. y .. ", gridSizeX " .. gridSizeX .. ", gridSizeY " .. gridSizeY );

			for ( int i = ( x < 1? x : x - 1 ); i < ( x >= gridSizeX? x + 1 : x + 2 ); i++ ) {
				for ( int j = ( y < 1? y : y - 1 ); j < ( y >= gridSizeY? y + 1 : y + 2 ); j++ ) {
					AutoAmbientListSpawnedKeeper curCell = gridX[ i ].y[ j ];

					if ( !curCell.Empty() && checkSpawnDistance( pos, curCell, useDistMultipl, lineDistSpawnChance ) )
						return true;
				}
			}
		}

		return false;
	} // of bool CheckForCloseNeighbours( vector3 pos, bool useDistMultipl, double lineDistSpawnChance ) {}


	void CreateGrid( void ) {
		leftLevelBound = g.leftLevelBound;
		topLevelBound = g.topLevelBound;

		double levelHorizontalSize = g.rightLevelBound - leftLevelBound;
		double levelVerticalSize = topLevelBound - g.bottomLevelBound;

		cellSideSize = actorsDistance;

		// Clamp minimal square (cell) side length to not-too-little value.
		if ( cellSideSize < minGridCellSideLength )
			cellSideSize = minGridCellSideLength;

		gridSizeX = int( ceil( levelHorizontalSize / cellSideSize ) ) + 1;
		gridSizeY = int( ceil( levelVerticalSize / cellSideSize ) ) + 1;

		// Scale amount of cells to fit to the limit.
		if ( gridSizeX > maxGridLength || gridSizeY > maxGridLength ) {
			int gridMaxSize = ( gridSizeX > gridSizeY? gridSizeX : gridSizeY );
			double prevCellSideSize = cellSideSize;

			cellSideSize = ceil( cellSideSize * ( gridMaxSize / double( maxGridLength ) ) );

			AutoAmbientLogger.Get().Log( LL_Debug, GetClassName() .. "::CreateGrid() for \"" .. TEXTCOLOR_GRAY .. name .. AutoAmbientLogger.LLCOLOR_Debug .. "\". Cell side resized from " .. prevCellSideSize .. " (x " .. gridSizeX .. ", y " .. gridSizeY .. ") to " .. cellSideSize );

			gridSizeX = int( ceil( levelHorizontalSize / cellSideSize ) ) + 1;
			gridSizeY = int( ceil( levelVerticalSize / cellSideSize ) ) + 1;
		}

		if ( gridSizeX <= 0 || gridSizeY <= 0 ) {
			AutoAmbientLogger.Get().Log( LL_Emergency, GetClassName() .. "::CreateGrid(). Array dimention is less or equal to zero. GridSize = ( " .. gridSizeX .. ", " .. gridSizeY .. "); level bbox: t " .. g.topLevelBound .. ", r " .. g.rightLevelBound .. ", b " .. g.bottomLevelBound .. ", l " .. g.leftLevelBound .. "; cell side size: " .. cellSideSize );
			return;
		}

		// Creating a grid itself.
		for ( int i = 0; i < gridSizeX; i++ ) {
			uint lastXIndex = gridX.Push( new( 'AutoAmbientSpawnedGridCellX' ) );
			AutoAmbientSpawnedGridCellX curCellX = gridX[ lastXIndex ];

			for ( int j = 0; j < gridSizeY; j++ )
				curCellX.y.Push( new( 'AutoAmbientListSpawnedKeeper' ) );
		}

		Actor actoriter = spawned.ActorIteratorBegin();

		while ( actoriter ) {
			AddToGrid( actoriter );
			actoriter = spawned.ActorIteratorNext();
		} // of while ( actoriter ) {}


		AutoAmbientLogger.Get().Log( LL_Debug, GetClassName() .. "::CreateGrid(). Created for \"" .. TEXTCOLOR_GRAY .. name .. AutoAmbientLogger.LLCOLOR_Debug .. "\". x " .. gridSizeX .. " (really " .. gridX.Size() .. "), y " .. gridSizeY .. "; moved " .. spawned.Size() .. " actors." );
	} // of void CreateGrid( void ) {}

	void PrintGrid( AutoAmbientLogger logger ) {
		logger.Log( LL_Debug, GetClassName() .. "::PrintGrid() for \"" .. TEXTCOLOR_BLUE .. name .. logger.LLCOLOR_Debug .. "\" (SizeX " .. gridSizeX .. ", SizeY " .. gridSizeY .. "):" );

		for ( int i = 0; i < gridSizeX; i++ ) {
			String gridstr = String.Format( " |- grid[%-2i]: ", i );

			for ( int j = 0; j < gridSizeY; j++ ) {
				uint curCellSize = gridX[ i ].y[ j ].Size();
				gridstr.AppendFormat( "%s%s", ( curCellSize == 0 )? logger.LLCOLOR_Debug : TEXTCOLOR_GREEN, ( curCellSize > 9 )? ">" : "" .. curCellSize );
			}

			logger.Log( LL_Debug, gridstr );
		}
	} // of void PrintGrid( void ) {}



	static AutoAmbientGroup Create( String groupname, double dist, AutoAmbientGlobalHandler globalhandler ) {
		AutoAmbientGroup newGroup = new( 'AutoAmbientGroup' );

		newGroup.name = groupname;
		newGroup.actorsDistance = dist;
		newGroup.g = globalhandler;

		newGroup.spawned = new( 'AutoAmbientListSpawnedKeeper' );
		newGroup.spawnedOnSide = new( 'AutoAmbientListSpawnedKeeper' );

		newGroup.autoclassConfig = new( 'AutoAmbientSoundActorConfiguration' );

		return newGroup;
	} // of static AutoAmbientGroup Create( String groupname, double dist, double spreading ) {}


	bool AddClass( class<Actor> cls ) {
		if ( cls )
			classes.Push( cls );

		return !!cls;
	} // of bool AddClass( class<Actor> cls ) {}

	bool AddSoundClass( AutoAmbientSoundDefinition sndclass ) {
		if ( sndclass )
			autoclasses.Push( sndclass );

		return !!sndclass;
	}

	bool AddAutoSoundClass( Sound snd, EAutoAmbientSoundModes mode = AASM_Looped, double vol = 1.0, double attn = 1.0, uint delay1 = 0, uint delay2 = 35 ) {
		AutoAmbientSoundDefinition newclass = AutoAmbientSoundDefinition.Create( "#snd_" .. snd, snd, mode, vol, attn, delay1, delay2 );

		if ( newclass )
			autoclasses.Push( newclass );

		return !!newclass;
	} // of bool AddAutoSoundClass( Sound snd, EAutoAmbientSoundModes mode = AASM_Looped, double vol = 1.0, double attn = 1.0, uint delay1 = 0, uint delay2 = 35 ) {}

	bool AddAutoLoopedSound( Sound snd, double vol = 1.0, double attn = 1.0 ) {
		return AddAutoSoundClass( snd, mode: AASM_Looped, vol: vol, attn: attn );
	}


	void ClearSpawned( void ) {
		if ( spawned )
			spawned.Clear();

		gridX.Clear();
		gridSizeX = 0;
		gridSizeY = 0;
	}

	bool GridCreated( void ) {
		return ( gridX.Size() > 0 );
	}


	private bool checkSpawnDistance( vector3 posToCheck, AutoAmbientListSpawnedKeeper listToCheck, bool useDistMultipl, double lineDistSpawnChance ) {
		bool grouplingTooClose = false;

		double nextChance = FRandom( 0.0, 1.0 );
		vector3 vecdist;

		// To prevent the in-cycle check with the same result I'd prefer to
		//split the cycles. Seriously.
		if ( !useDistMultipl ) {
			Actor actoriter = listToCheck.ActorIteratorBegin();

			while ( actoriter ) {
				vecdist = posToCheck - actoriter.pos;

				if ( vecdist.Length() < actorsDistance ) {
					if ( nextChance < lineDistSpawnChance ) {
						//console.printf( "     nextChance (" .. nextChance .. ") < lineDistSpawnChance (" .. lineDistSpawnChance .. ")" );
						nextChance = FRandom( 0.0, 1.0 );
					} else {
						//console.printf( " BRK nextChance (" .. nextChance .. ") >= lineDistSpawnChance (" .. lineDistSpawnChance .. ")" );
						grouplingTooClose = true;
						break;
					}
				}

				actoriter = listToCheck.ActorIteratorNext();
			} // of while ( actoriter ) {}

		} else {
			Actor actoriter = listToCheck.ActorIteratorBegin();

			while ( actoriter ) {
				vecdist = posToCheck - actoriter.pos;

				if ( vecdist.Length() < actorsDistance ) {
					if ( nextChance < lineDistSpawnChance * vecdist.Length() / actorsDistance ) {
						nextChance = FRandom( 0.0, 1.0 );
					} else {
						grouplingTooClose = true;
						break;
					}
				}

				actoriter = listToCheck.ActorIteratorNext();
			} // of while ( actoriter ) {}

		} // of else of if ( useDistMultipl ) {}

		return grouplingTooClose;
	} // of private bool checkSpawnDistance( vector3 posToCheck, AutoAmbientListSpawnedKeeper listToCheck, bool useDistMultipl, double lineDistSpawnChance ) {}


	int SpawnActor( Side attachSide, int sidePos, AutoAmbientTexture texdef, uint groupPos ) {
		AutoAmbientLogger logger = AutoAmbientLogger.Get();

		if ( !classes.Size() && !autoclasses.Size() )
			return 0; // We cannot spawn something if we have no spawn data.

		if ( !texdef )
			return 0; // Return if there's no neccesary texture definition.

		// Locate a texture definition:
		TextureID texID = attachSide.GetTexture( sidePos );

		Line attachLine = attachSide.linedef;

		//console.printf( "action: " .. attachLine.special .. ", com " .. texdef.linesCheckFlags & AALCF_CommonLine .. " / act " .. texdef.linesCheckFlags & AALCF_ActionLine );
		if ( 	( !attachLine.special && !( texdef.linesCheckFlags & AALCF_HandleCommonLines ) )
			||	(  attachLine.special && !( texdef.linesCheckFlags & AALCF_HandleActionLines ) ) )
			return 0; // Return if user denies current line (action or common) spawning.

		AutoAmbientTextureParameter texparam = texdef.groupparams[ groupPos ];

		Side oppositeSide = ( ( attachLine.sidedef[ 0 ] == attachSide )? attachLine.sidedef[ 1 ] : attachLine.sidedef[ 0 ] );
		double lineWidth = attachLine.delta.Length();
		double lineHeight = 0;
		double firstPointFloorZOffset = 0.0;

		double unpeggedOffset = 0.0;

		// [A]ttaching/[O]pposite side, [F]loor/[C]eiling heights:
		double af = attachSide.sector.floorplane.d * attachSide.sector.floorplane.negiC;
		double ac = attachSide.sector.ceilingplane.d * attachSide.sector.ceilingplane.negiC;
		double of = 0.0;
		double oc = 0.0;
		if ( oppositeSide ) {
			of = oppositeSide.sector.floorplane.d * oppositeSide.sector.floorplane.negiC;
			oc = oppositeSide.sector.ceilingplane.d * oppositeSide.sector.ceilingplane.negiC;
		}

		switch ( sidePos ) {
			case Side.top:
				if ( oppositeSide ) {
					if ( oppositeSide.sector.GetTexture( Sector.ceiling ) == skyflatnum && ac > oc )
						return 0; // Sky lines skipping (see "TNT: Evilution", MAP27 "Mount pain").

					lineHeight = max( 0, ac - oc );
					if ( lineHeight > 0 )
						lineHeight = min( lineHeight, ac - af );

					firstPointFloorZOffset = oc - af;

					if ( attachLine.flags & Line.ML_DONTPEGTOP )
						unpeggedOffset = ( lineHeight - texdef.size.y ) % texdef.size.y;
				}
				break;
			case Side.mid:
				lineHeight = max( 0, ac - af );

				// TODO: cannot recognize now what must be here...
				//if ( lineHeight > 0 )
				//	lineHeight = min( lineHeight, oc - of );

				if ( !( attachLine.flags & Line.ML_DONTPEGBOTTOM ) )
					unpeggedOffset = ( lineHeight - texdef.size.y ) % texdef.size.y;
				break;
			case Side.bottom:
				if ( oppositeSide ) {
					//if ( oppositeSide.sector.GetTexture( Sector.floor ) == skyflatnum && af < ac )
					//	return 0; // Don't sure if FSKY1 expands to the floors.

					lineHeight = max( 0, of - af );
					if ( lineHeight > 0 )
						lineHeight = min( lineHeight, ac - af );

					if ( !( attachLine.flags & Line.ML_DONTPEGBOTTOM ) )
						unpeggedOffset = lineHeight - texdef.size.y;
					else
						unpeggedOffset = ( ac - af ) % texdef.size.y;
				}
				break;
			default:
				break;
		} // of switch ( sidePos ) {}


		if ( lineHeight == 0.0 || lineWidth == 0.0 )
			return 0; // There's no point in creating an actor if the texture is not visible.

		if ( lineHeight < 0.0 || lineWidth < 0.0 ) {
			logger.Log( LL_Emergency, GetClassName() .. "::SpawnActor(). Line #" .. attachLine.Index() .. " calculated height " .. lineHeight .. "/width " .. lineWidth .. " is less than 0. It's at least extremely strange." );
			return 0;
		}


		if ( unpeggedOffset != 0.0 )
			unpeggedOffset = texdef.size.y - unpeggedOffset;

		vector3 firstPoint = ( // From bottom-left (as first quadrant on cartesian plane).
				attachLine.v1.p.x,
				attachLine.v1.p.y,
				af + firstPointFloorZOffset
		);

		uint classesArraySize = classes.Size();

		int totalspawnedOnSide = 0;

		//String debugTextureName = TexMan.GetName( texID );
		//if ( debugTextureName == "BIGBRIK3" ) {
		//	console.printf( debugTextureName .. ": start.y = (" .. texMapOffset.y  .. " + " .. texparam.start.y .. ") % " .. texdef.size.y .. " = " .. ( texMapOffset.y + texparam.start.y ) % texdef.size.y .. ", end.y " .. lineHeight .. ". tex.offsety: " .. attachSide.GetTextureYOffset( sidePos ) ); // .. ". texparam.offset.x: " .. texparam.offset.x );
		//}

		// Converting virtual 2D-plane to the 3D-aligned line plane
		//and adding potential positions to the array:
		for ( double texz = ( attachSide.GetTextureYOffset( sidePos ) + texparam.start.y ) % texdef.size.y - unpeggedOffset; texz < lineHeight / ( texparam.offset.y / texdef.size.y ); texz += texparam.offset.y ) {
			for ( double texxy = ( texparam.start.x - attachSide.GetTextureXOffset( sidePos ) % texdef.size.x ) % texdef.size.x; texxy < lineWidth / ( texparam.offset.x / texdef.size.x ); texxy += texparam.offset.x ) {

				if ( texparam.chance != 0.0 && FRandom( 0.0, 1.0 ) > texparam.chance )
					continue; // Skip spawning if texture parameter chance to spawn failed.

				double texxyRandomized = texxy + FRandom( -texparam.spreading.x, texparam.spreading.x );
				double texzRandomized = texz + FRandom( -texparam.spreading.y, texparam.spreading.y );

				if ( texxyRandomized < 0.0 || texxyRandomized > lineWidth || texzRandomized < 0.0 || texzRandomized > lineHeight )
					continue; // Skip spawning if random tried to spawn actor outside the texture.

				// Converting to the world 3D-coordinates. Normalizing
				//(v1-v2), multiplying it to the wish length...
				vector2 actorPosXY = firstPoint.xy + attachLine.delta / lineWidth * texxyRandomized;
				// ...And adding a Z-component:
				vector3 newPos = ( actorPosXY.x, actorPosXY.y, firstPoint.z + texzRandomized );

				//console.printf( "Actor for tex \"" .. TexMan.GetName( texdef.id ) .. "\": relpos " .. actorPosXY - firstPoint.xy .. ", firstPointPos " .. firstPoint .. ", texMapOfs " .. texMapOffset .. ", line w/h " .. lineWidth .. "/" .. lineHeight );

				bool grouplingTooClose = false; // Same meaning as in word "Sibling".

				// Removing position if it are not far enough away from
				//previously spawned actors on current line and/or other lines:
				if ( texdef.sameLineDistSpawnChance < 1.0 && !spawnedOnSide.Empty() )
					grouplingTooClose = checkSpawnDistance( newPos, spawnedOnSide, texdef.linesCheckFlags & AALCF_SelfLineDistMultipl, texdef.sameLineDistSpawnChance );

				if ( texdef.otherLineDistSpawnChance < 1.0 && !grouplingTooClose )
					grouplingTooClose = CheckForCloseNeighbours( newPos, texdef.linesCheckFlags & AALCF_OtherLinesDistMultipl, texdef.otherLineDistSpawnChance );
				//	grouplingTooClose = checkSpawnDistance( newPos, spawned, texdef.linesCheckFlags & AALCF_OtherLinesDistMultipl, texdef.otherLineDistSpawnChance );

				// Adding new actor to the array if it may be created:
				if ( !grouplingTooClose ) {
					Actor newActor = NULL;

					// Get a random class from the (auto)classes arrays:
					uint rnd = Random( 0, classesArraySize + autoclasses.Size() - 1 );

					if ( rnd < classesArraySize ) {
						newActor = Actor.Spawn( classes[ rnd ], newPos );
					} else if ( autoclasses.Size() ) {
						// An expandable part of the code (maybe later...).
						class<AutoAmbientSoundActor> properclass = autoclassConfig.GetProperClass( autoclasses[ rnd - classesArraySize ] );

						newActor = Actor.Spawn( properclass, newPos );
						AutoAmbientSoundActor( newActor ).Init( autoclasses[ rnd - classesArraySize ] );
					} else {
						logger.Log( LL_Emergency, GetClassName() .. "::SpawnActor(). Warning: random value " .. rnd .. " is out-of-bounds of classes[ " .. classesArraySize .. " ] and autoclasses[ " .. autoclasses.Size() .. " ]." );
					}

					if ( newActor ) {
						if ( newActor is 'AutoAmbientSpawnableActor' ) {
							AutoAmbientSpawnableActor( newActor ).attachedSide = attachSide;

							vector2 lineNormal = Actor.RotateVector( attachLine.delta / lineWidth, ( ( attachSide == attachLine.sidedef[ 0 ] )? 90.0 : -90.0 ) ); // Not sure if this line is correct, actually.

							newActor.angle = AutoAmbientUtil.vector2ToAngle( lineNormal );
						}

						spawnedOnSide.AppendSpawnedActor( newActor );
						totalspawnedOnSide++;

						if ( logger.aaCurLogLevel >= LL_Detailed )
							logger.Log( LL_Detailed, TEXTCOLOR_GRAY .. "Actor \c-" .. newActor.GetClassName() .. TEXTCOLOR_GRAY .. " spawned on \"\c-" .. texID .. "->" .. name .. TEXTCOLOR_GRAY .. "\" at " .. AutoAmbientUtil.squeezeVector3( newActor.pos ) .. "." );
					}
				} // of if ( !grouplingTooClose ) {}

			} // of for ( double texxy = ( texMapOffset.x + texparam.start.x ) % texdef.size.x; texxy < lineWidth; texxy += texparam.offset.x ) {}
		} // of for ( double texz = ( texMapOffset.y + texparam.start.y ) % texdef.size.y; texz < lineHeight; texz += texparam.offset.y ) {}

		return totalspawnedOnSide;
	}  // of void SpawnActor( Side attachSide, int sidePos, AutoAmbientTexture texdef, uint groupPos ) {}

	void FlushSpawnLineActors( void ) {
		Actor actoriter = spawnedOnSide.ActorIteratorBegin();

		if ( GridCreated() ) {
			while ( actoriter ) {
				AddToGrid( actoriter );
				actoriter = spawnedOnSide.ActorIteratorNext();
			} // of while ( actoriter ) {}
		}

		spawnedOnSide.AppendMoveToList( spawned );

		if ( !GridCreated() && spawned.Size() > wholeListAlgorithmMaxSpawnedSize )
			CreateGrid();

		//if ( !spawnedOnSide.Empty() && AutoAmbientLogger.Get().aaCurLogLevel >= LL_Debug )
		//	AutoAmbientLogger.Get().Log( LL_Debug, GetClassName() .. "::FlushSpawnLineActors(). Actors flushed." );

		//spawnedOnSide.Clear();
	} // of void FlushSpawnLineActors( void ) {}

} // of class AutoAmbientGroup {}



class AutoAmbientSpawnableActor: Actor abstract {
	Side attachedSide;
	// An angle also sets up on spawn (from the normal vector).
}

class AutoAmbientSoundActorConfiguration play {
	virtual class<AutoAmbientSoundActor> GetProperClass( AutoAmbientSoundDefinition def ) {
		class<AutoAmbientSoundActor> outClass;

		switch ( def.sndMode ) {
			case AASM_Looped:
				outClass = "AutoAmbientLoopedSound";
				break;
			case AASM_Fixed:
				outClass = "AutoAmbientFixDlySound";
				break;
			case AASM_Random:
				outClass = "AutoAmbientRndDlySound";
				break;
			default:
				AutoAmbientLogger.Get().Log( LL_Main, GetClassName() .. "::GetProperClass(). Sound mode " .. def.sndMode .. " isn't recognized." );
				break;
		}

		return outClass;
	}

} // of class AutoAmbientSoundActorConfiguration play {}


class AutoAmbientSoundActor: Actor abstract {
	AutoAmbientSoundDefinition def;
	bool actorInitialized; // Call "Init()" with right arguments to set it up.

	// Here are stored the most used and local variables:
	EAutoAmbientSoundModes playsoundMode;
	uint minDelay, maxDelay, curDelay;

	Default {
		+INVISIBLE;
		+BRIGHT;

		+NOINTERACTION;
		+NOBLOCKMAP;
		Scale 0.2;
		Alpha 1.0;
		RenderStyle "STYLE_Stencil";
	}

	virtual void Init( AutoAmbientSoundDefinition initDef ) {
		def = initDef;
		actorInitialized = ( def && ( def.snd != "" ) && ( def.snd != "null" ) );
	} // of virtual void Init( AutoAmbientSoundDefinition initDef ) {}

	virtual void OnSpawn( void ) {
		SetShade( "00 00 88" );
	}


	override final void PostBeginPlay() {
		Super.PostBeginPlay();

		if ( actorInitialized ) {
			OnSpawn();
		} else {
			String soundInfo;

			if ( !def )
				soundInfo = "without linked sound definition";
			else if ( ( def.snd == "" ) || ( def.snd == "null" ) )
				soundInfo = "with no linked sound (wrong sound name in configuration file?)";
			else
				soundInfo = "with sound \"" .. def.snd .. "\"";

			AutoAmbientLogger.Get().Log( LL_Main, GetClassName() .. " at " .. AutoAmbientUtil.squeezeVector3( pos ) .. " " .. soundInfo .. " not initialized properly and thus destroyed." );
			Destroy();
		}
	} // of override void PostBeginPlay() {}

	States {
	Spawn:
		TNT1 A 0;
		SPKR A -1;
		stop;
	}
} // of class AutoAmbientSoundActor: Actor {}


class AutoAmbientLoopedSound: AutoAmbientSoundActor {
	override void OnSpawn( void ) {
		Super.OnSpawn();

		curDelay = Random( 0, 7 );
	}

	override void Tick() {
		if ( curDelay >= 0 ) {
			if ( --curDelay < 0 )
				A_PlaySound( def.snd, CHAN_AUTO, def.sndVolume, true, def.sndAttenuation );
		}

		Super.Tick();
	}

} // of AutoAmbientLoopedSound: AutoAmbientSoundActor {}

class AutoAmbientFixDlySound: AutoAmbientSoundActor {
	override void OnSpawn( void ) {
		Super.OnSpawn();
		curDelay = Random( 0, maxDelay );
	}

	override void Init( AutoAmbientSoundDefinition initDef ) {
		Super.Init( initDef );

		minDelay = maxDelay = def.minDelay;
	}

	override void Tick() {
		if ( curDelay-- <= 0 ) {
			A_PlaySound( def.snd, CHAN_AUTO, def.sndVolume, false, def.sndAttenuation );
			curDelay = minDelay;
		}

		Super.Tick();
	}
} // of class AutoAmbientFixDlySound: AutoAmbientSoundActor {}

class AutoAmbientRndDlySound: AutoAmbientSoundActor {
	override void Init( AutoAmbientSoundDefinition initDef ) {
		Super.Init( initDef );

		minDelay = def.minDelay;
		maxDelay = def.maxDelay;
	}

	override void Tick() {
		if ( curDelay-- <= 0 ) {
			A_PlaySound( def.snd, CHAN_AUTO, def.sndVolume, false, def.sndAttenuation );
			curDelay = Random( minDelay, maxDelay );
		}

		Super.Tick();
	}
} // of class AutoAmbientRndDlySound: AutoAmbientSoundActor {}

