
class AutoAmbientGroup play {
	String name;
	Array< class<Actor> > classes;
	Array<AutoAmbientSoundDefinition> autoclasses;
	double actorsDistance;

	//TextureID cachedTexture;
	//AutoAmbientTexture cachedTextureDefinition;
	//Array<AutoAmbientTextureDefinition> textures;

	Array<Actor> spawned; // All spawned on the level auto actors for this group.

	static AutoAmbientGroup Create( String groupname, double dist ) {
		AutoAmbientGroup newGroup = new( 'AutoAmbientGroup' );

		newGroup.name = groupname;
		newGroup.actorsDistance = dist;

		return newGroup;
	} // of static AutoAmbientGroup Create( String groupname, double dist, double spreading ) {}


	bool AddClass( class<Actor> cls ) {
		if ( cls )
			classes.Push( cls );

		return !!cls;
	} // of bool AddClass( class<Actor> cls ) {}

	bool AddSoundClass( AutoAmbientSoundDefinition sndclass ) {
		if ( sndclass )
			autoclasses.Push( sndclass );

		return !!sndclass;
	}

	bool AddAutoSoundClass( Sound snd, EAutoAmbientSoundModes mode = AASM_Looped, double vol = 1.0, double attn = 1.0, uint delay1 = 0, uint delay2 = 35 ) {
		AutoAmbientSoundDefinition newclass = AutoAmbientSoundDefinition.Create( snd, snd, mode, vol, attn, delay1, delay2 );

		if ( newclass )
			autoclasses.Push( newclass );

		return !!newclass;
	} // of bool AddAutoSoundClass( Sound snd, EAutoAmbientSoundModes mode = AASM_Looped, double vol = 1.0, double attn = 1.0, uint delay1 = 0, uint delay2 = 35 ) {}

	bool AddAutoLoopedSound( Sound snd, double vol = 1.0, double attn = 1.0 ) {
		return AddAutoSoundClass( snd, mode: AASM_Looped, vol: vol, attn: attn );
	}


	void ClearSpawned( void ) {
		spawned.Clear();
	}

	// Right now I'm too lazy to copy-paste code with refactoring identifiers
	//to the AutoAmbientTexture.
	void SpawnActor( Side attachSide, int sidePos, AutoAmbientTexture texdef, uint groupPos ) {
		if ( !classes.Size() && !autoclasses.Size() )
			return; // We cannot spawn something if we have no spawn data.

		// Locate a texture definition:
		TextureID texID = attachSide.GetTexture( sidePos );

		//console.printf( GetClassName() .. "::SpawnActor(). \"" .. texID .. "\" handle." );

		// See GZDoom source code, "/src/common/textures/textureid.h"
		//("class FTextureID"). TextureID comparing is really much faster 
		//than same for String. Also cache may help in speeding up at least 
		//something, about 5-20% in my opinion.
		/*if ( cachedTextureDefinition && texID == cachedTextureDefinition.id ) {
			texdef = cachedTextureDefinition;
		} else {
			for ( int i = 0; i < textures.Size(); i++ )
				if ( textures[ i ].id == texID ) {
					cachedTextureDefinition = texdef = textures[ i ];
					break;
				}
		}*/
		//console.printf( name .. "/\"" ..  TexMan.GetName( texID ) .. "\". TextureDef: " .. texdef );

		if ( !texdef )
			return; // Return if there's no neccesary texture definition.

		AutoAmbientTextureParameter texparam = texdef.groupparams[ groupPos ];

		Line attachLine = attachSide.linedef;
		Side oppositeSide = ( attachLine.sidedef[ 0 ] == attachSide )? attachLine.sidedef[ 1 ] : attachLine.sidedef[ 0 ];
		double lineWidth = attachLine.delta.Length();
		double lineHeight = 0;
		double firstPointFloorZOffset = 0.0;

		double unpeggedOffset = 0.0;

		// [A]ttach/[O]pposite side, [F]loor/[C]eiling heights:
		double af = attachSide.sector.floorplane.d * attachSide.sector.floorplane.negiC;
		double ac = attachSide.sector.ceilingplane.d * attachSide.sector.ceilingplane.negiC;
		double of = 0.0;
		double oc = 0.0;
		if ( oppositeSide ) {
			of = oppositeSide.sector.floorplane.d * oppositeSide.sector.floorplane.negiC;
			oc = oppositeSide.sector.ceilingplane.d * oppositeSide.sector.ceilingplane.negiC;
		}

		switch ( sidePos ) {
			case Side.top:
				if ( oppositeSide ) {
					lineHeight = max( 0, ac - oc );
					if ( lineHeight > 0 )
						lineHeight = min( lineHeight, ac - af );

					firstPointFloorZOffset = oc - af;

					if ( attachLine.flags & Line.ML_DONTPEGTOP )
						unpeggedOffset = ( lineHeight - texdef.size.y ) % texdef.size.y;
				}
				break;
			case Side.mid:
				lineHeight = max( 0, ac - af );

				// Cannot recognize now what must be here...
				//if ( lineHeight > 0 )
				//	lineHeight = min( lineHeight, oc - of );

				if ( !( attachLine.flags & Line.ML_DONTPEGBOTTOM ) )
					unpeggedOffset = ( lineHeight - texdef.size.y ) % texdef.size.y;
				break;
			case Side.bottom:
				if ( oppositeSide ) {
					lineHeight = max( 0, of - af );
					if ( lineHeight > 0 )
						lineHeight = min( lineHeight, ac - af );

					if ( !( attachLine.flags & Line.ML_DONTPEGBOTTOM ) )
						unpeggedOffset = lineHeight - texdef.size.y;
					else 
						unpeggedOffset = ( ac - af ) % texdef.size.y;
				}
				break;
			default:
				break;
		} // of switch ( sidePos ) {


		if ( lineHeight <= 0 && !( attachLine.special && texdef.actionlineCheck == AAAC_AlsoZeroHeight ) )
			return; // There's no point in creating an actor if the texture is not visible.

		//if ( lineWidth <= texdef.size.x && lineHeight <= texdef.size.y && FRandom( 0.0, 1.0 ) > texparam.chance )
		//	return; // Return if chance to spawn on small line failed.


		vector2 texMapOffset = (
				attachSide.GetTextureXOffset( sidePos ) % texdef.size.x,
				( attachSide.GetTextureYOffset( sidePos ) + unpeggedOffset ) % texdef.size.y
		);

		vector3 firstPoint = ( // From bottom-left.
				attachLine.v1.p.x,
				attachLine.v1.p.y,
				af + firstPointFloorZOffset
		);

		uint classesArraySize = classes.Size();
		uint alreadySpawnedArraySize = spawned.Size();

		//String debugTextureName = TexMan.GetName( texID );
		//if ( debugTextureName == "BIGBRIK3" ) {
		//	console.printf( debugTextureName .. ": start.y = (" .. texMapOffset.y  .. " + " .. texparam.start.y .. ") % " .. texdef.size.y .. " = " .. ( texMapOffset.y + texparam.start.y ) % texdef.size.y .. ", end.y " .. lineHeight .. ". tex.offsety: " .. attachSide.GetTextureYOffset( sidePos ) ); // .. ". texparam.offset.x: " .. texparam.offset.x );
		//}

		// Converting virtual 2D-plane to the 3D-aligned line plane
		//and adding potential positions to the array:
		for ( double texz = ( texMapOffset.y + texparam.start.y ) % texdef.size.y; texz < lineHeight; texz += texparam.offset.y ) {
			for ( double texxy = ( texMapOffset.x + texparam.start.x ) % texdef.size.x; texxy < lineWidth; texxy += texparam.offset.x ) {
				if ( texparam.chance != 0.0 && FRandom( 0.0, 1.0 ) > texparam.chance )
					continue; // Skip spawning if chance to spawn failed.

				double texxyRandomized = texxy + FRandom( -texparam.spreading.x, texparam.spreading.x );
				double texzRandomized = texz + FRandom( -texparam.spreading.y, texparam.spreading.y );

				if ( texxyRandomized < 0.0 || texxyRandomized > lineWidth || texzRandomized < 0.0 || texzRandomized > lineHeight )
					continue; // Skip spawning if random tried to spawn actor outside the texture.

				// Converting to the world 3D-coordinates. Normalizing 
				//(v1-v2), multiplying it to the wish length...
				vector2 actorPosXY = firstPoint.xy + attachLine.delta / lineWidth * texxyRandomized;
				// ...And adding a Z-component:
				vector3 newPos = ( actorPosXY.x, actorPosXY.y, firstPoint.z + texzRandomized );

				//console.printf( "Actor for tex \"" .. TexMan.GetName( texdef.id ) .. "\": relpos " .. actorPosXY - firstPoint.xy .. ", firstPointPos " .. firstPoint .. ", texMapOfs " .. texMapOffset .. ", line w/h " .. lineWidth .. "/" .. lineHeight );

				bool grouplingTooClose = false; // Same meaning as in word "Sibling".

				// Removing position if it are not far enough away from 
				//previously spawned actors:
				for ( int j = 0; j < alreadySpawnedArraySize; j++ ) {
					vector2 vecdist = newPos.xy - spawned[ j ].pos.xy;

					if ( vecdist.Length() < actorsDistance ) {
						grouplingTooClose = true;
						break;
					}
				}

				// Adding to the an actor if it may be created:
				if ( !grouplingTooClose ) {
					Actor newActor = NULL;

					// Get a random class from the (auto)classes arrays:
					uint rnd = Random( 0, classesArraySize + autoclasses.Size() - 1 );

					if ( rnd < classesArraySize ) {
						newActor = Actor.Spawn( classes[ rnd ], newPos );
					} else if ( autoclasses.Size() ) {
						newActor = Actor.Spawn( "AutoAmbientSoundActor", newPos );
						AutoAmbientSoundActor( newActor ).Init( autoclasses[ rnd - classesArraySize ] );
					} else {
						console.printf( "Warning: random getter " .. rnd .. " is out-of-bounds of classes[ " .. classesArraySize .. " ] and autoclasses[ " .. autoclasses.Size() .. " ]." );
					}

					if ( newActor ) {
						spawned.Push( newActor );
						//console.printf( "\"" .. texID .. "\"->" .. name .. ". Actor " .. newActor.GetClassName() .. " spawned at " .. newActor.pos .. "." );
						console.printf( "Actor \"" .. newActor.GetClassName() .. "\" from group " .. name .. " spawned at " .. newActor.pos .. " (texture \"" .. texID .. "\")." );
					}
				} // of if ( !grouplingTooClose ) {}

			} // of for ( double texxy = ( texMapOffset.x + texparam.start.x ) % texdef.size.x; texxy < lineWidth; texxy += texparam.offset.x ) {}
		} // of for ( double texz = ( texMapOffset.y + texparam.start.y ) % texdef.size.y; texz < lineHeight; texz += texparam.offset.y ) {}

	} // of void SpawnActor( Side attachSide, int sidePos ) {}

} // of class AutoAmbientGroup {}


class AutoAmbientSoundActor: Actor {
	AutoAmbientSoundDefinition def;
	bool actorInitialized; // Call "Init()" with right arguments to set it up.

	// Here are stored the most used and local variables:
	EAutoAmbientSoundModes playsoundMode;
	uint minDelay, maxDelay, curDelay;


	Default {
		+NOINTERACTION;
		+NOBLOCKMAP;
		+INVISIBLE;
	}

	void Init( AutoAmbientSoundDefinition initDef ) {
		def = initDef;

		actorInitialized = ( def && ( def.snd != "" ) && ( def.snd != "null" ) );

		if ( actorInitialized ) {
			playsoundMode = def.sndMode;

			switch ( playsoundMode ) {
				case AASM_Looped:
					break;
				case AASM_Fixed:
					minDelay = maxDelay = def.minDelay;
					break;
				case AASM_Random:
					minDelay = def.minDelay;
					maxDelay = def.maxDelay;
					break;
				default:
					console.printf( "Error: cannot init actor, sound mode " .. playsoundMode .. " isn't recognized." );
					actorInitialized = false;
					break;
			}
		}
	} // of void Init( EAutoAmbientSoundModes mode, Sound soundToPlay, double volume = 1.0, double attn = 1.0, uint delay1 = 0, uint delay2 = 0 ) {}


	override void PostBeginPlay() {
		Super.PostBeginPlay();

		if ( actorInitialized ) {
			curDelay = Random( 0, ( (playsoundMode == AASM_Looped)? 5 : maxDelay ) );
		} else {
			console.printf( GetClassName() .. "::PostBeginPlay(). Actor at " .. pos .. " not initialized (wrong sound provided?). Destroying self." );
			Destroy();
		}
	} // of override void PostBeginPlay() {}

	override void Tick() {
		// Must not stop on globalfreeze.

		switch ( playsoundMode ) {
			case AASM_Fixed:
			case AASM_Random:
				if ( curDelay-- <= 0 ) {
					A_PlaySound( def.snd, CHAN_AUTO, def.sndVolume, false, def.sndAttenuation );
					//S_Sound( def.snd, CHAN_AUTO, def.sndVolume, def.sndAttenuation );
					curDelay = ( playsoundMode == AASM_Fixed )? minDelay : Random( minDelay, maxDelay );
				}
				break;
			case AASM_Looped: // Light randomization.
				if ( curDelay >= 0 ) {
					if ( --curDelay < 0 ) {
						//console.printf( "Looped sound " .. def.snd .. ", volume " .. def.sndVolume .. "." );
						A_PlaySound( def.snd, CHAN_AUTO, def.sndVolume, true, def.sndAttenuation );
					}
				}
				break;
			default:
				break;
		}

		Super.Tick();
	} // of override void Tick() {}

	States {
	Spawn:
		TNT1 A 0;
		BAL2 A -1;
		stop;
	}
} // of class AutoAmbientSoundActor: Actor {}
