version "2.4.0"

#include "ZScript/DataClasses.zsc"
#include "ZScript/AutoActors.zsc"

enum EAutoAmbientSoundModes {
	AASM_Looped = 0,
	AASM_Fixed,
	AASM_Random
};

enum EAutoAmbientSamelineCheck {
	AASC_On = 0,		// Default.
	AASC_Off,
	AASC_Only
};

enum EAutoAmbientActionlineCheck {
	AAAC_Default = 0,
	AAAC_Ignore,
	AAAC_AlsoZeroHeight
};


class AutoAmbientHandler: StaticEventHandler {
	const AutoAmbientHandlerOrder = 0x7FAA0003;

	Array<AutoAmbientTexture> textures;
	Array<AutoAmbientGroup> groups;
	//Array<AutoAmbientGroupCache> groupcache; // Just a list which must be ordered by use frequency.

	// Temporary methods, just for convenience.
	int lastGroupIndex;
	void AddGroupToTexture( AutoAmbientTexture tex, uint groupIndex, vector2 start = ( -1.0, -1.0 ), vector2 offset = ( -1.0, -1.0 ), vector2 rnd = ( 0.0, 0.0 ) ) {
		AutoAmbientTextureParameter newtexparam = AutoAmbientTextureParameter.Create( start, offset, rnd, 1.0 );
		tex.AddGroupParam( groups[ groupIndex ], newtexparam );
	}

	AutoAmbientTexture AddTexture( Name textureName, vector2 start = ( -1.0, -1.0 ), vector2 offset = ( -1.0, -1.0 ), vector2 rnd = ( 0.0, 0.0 ) ) {
		AutoAmbientTexture newtex = AutoAmbientTexture.Create( textureName );
		AddGroupToTexture( newtex, lastGroupIndex, start, offset, rnd );
		uint lastpos = textures.Push( newtex );
		return textures[ lastpos ];
	}

	AutoAmbientTexture FindInvalidTexture( void ) {
		for ( int i = 0; i < textures.Size(); i++ )
			if ( !textures[ i ].Validate() )
				return textures[ i ];

		return NULL;
	}

	// Configuration (in future a file parser):
	override void OnRegister() {
		SetOrder( AutoAmbientHandlerOrder );

		lastGroupIndex = -1;
		groups.Clear(); 
		//groupcache.Clear();
		textures.Clear();

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Pipe", 256 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Pipes", vol: 0.4, attn: 4 );
		AddTexture( "BROWNPIP" );
		AddTexture( "METAL4" );
		AddTexture( "PIPE2" );
		AddTexture( "PIPE6" );
		AddTexture( "PIPEWAL1" );
		AddTexture( "PIPES" );
		AddTexture( "SW1PIPE" );
		AddTexture( "SW2PIPE" );
		AddTexture( "TEKGREN4" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Comp", 128 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Computers/Beep", AASM_Fixed, 0.4, 5.0, 35 );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Computers/Boop", AASM_Fixed, 0.4, 5.0, 35 );
		AddTexture( "COMPSTA1" );
		AddTexture( "COMPSTA2" );
		AddTexture( "COMPTALL", start: ( 32.0, 64.0 ), offset: ( 96.0, 0.0 ) );
		AddTexture( "SILVER3" );
		AddTexture( "SPACEW3", rnd: ( 0.0, 24.0 ) );
		//groups[ 0 ].AddClass( "AutoAmbientActor_Comp" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Tech", 192 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Tech", vol: 0.6, attn: 3.5 );
		AddTexture( "CEMENT2" );
		AddTexture( "CEMENT4" );
		AddTexture( "ICKWALL4" );
		AddTexture( "SW1COMP" );
		AddTexture( "SW2COMP" );
		AddTexture( "COMPTALL" );
		AddTexture( "COMPWERD" );
		AddTexture( "TEKGREN1" );
		AddTexture( "TEKWALL1" );
		AddTexture( "TEKWALL4" );
		AddTexture( "TEKWALL6" );
		AddTexture( "ZZZFACE6" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "BloodPipe", 128 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/BloodPipes", vol: 0.6, attn: 4.2 );
		AddTexture( "BLODRIP1" );
		AddTexture( "BLODRIP2" );
		AddTexture( "BLODRIP3" );
		AddTexture( "BLODRIP4" );
		AddTexture( "PIPE1" );
		AddTexture( "SK_LEFT" );
		AddTexture( "SK_RIGHT" );
		AddTexture( "SLOPPY2" );

		console.printf( GetClassName() .. "::OnRegister(). Reloading configuration done." );
		Super.OnRegister();
	}


	override void WorldLoaded( WorldEvent e ) {
		AutoAmbientTexture invalidTexture = FindInvalidTexture();

		if ( invalidTexture ) {
			console.printf( GetClassName() .. "::WorldLoaded(). ERROR: texture definition ID " .. invalidTexture.id .. " is not valid." );
			console.printf( GetClassName() .. "::WorldLoaded(). Texture name: " .. TexMan.GetName( invalidTexture.id ) );
			Super.WorldLoaded( e );
			return;
		}

		// Static event handler may save information through levels.
		for ( int i = 0; i < groups.Size(); i++ )
			groups[ i ].ClearSpawned();


		// A-a-argh! Seven nested "for" cycles in worst case!..
		//(Alright, it's non-exponential dependence, most of them has from one 
		//to three iterations).
		for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {
			Side l = level.Sides[ curSideIndex ];

			for ( int curSidePos = 0; curSidePos < 2; curSidePos++ ) {
				TextureID texID = l.GetTexture( curSidePos );

				if ( texID ) {
					//console.printf( "Texture \"" .. TexMan.GetName( texID ) .. "\"." );
					//AutoAmbientGroupCache texCache = NULL;

					// Attempt to find texture in cache array:
					/*for ( int j = 0; j < groupcache.Size(); j++ ) {
						if ( groupcache[ j ].texture == texID ) {
							texCache = groupcache[ j ];
							groupcache[ j ].frequency++;

							// Ordering by use frequency:
							/*if ( j > 0 && groupcache[ j ].frequency > groupcache[ j - 1 ].frequency ) {
								// Really slow executing caused by universality.
								//Moreover, lines below will swap only neighbour
								//elements ("2, 1, 1, 2" -> "2, 1, 2, 1").
								groupcache.Insert( j - 1, groupcache[ j ] );
								groupcache.Delete( j + 1, 1 );
							} * /
							break;
						}
					} // of for ( int j = 0; j < groupcache.Size(); j++ ) {

					// Creating new texture cache if necessary:
					if ( !texCache ) {
						texCache = new( 'AutoAmbientGroupCache' );
						texCache.texture = texID;
						texCache.frequency = 1;

						// Different groups may handle one texture.
						for ( int j = 0; j < groups.Size(); j++ ) {
							if ( groups[ j ].IsTextureInGroup( texID ) )
								texCache.groups.Push( groups[ j ] );
						}

						groupcache.Push( texCache );
					}

					// Spawning actor(s) according to the cached groups:
					for ( int j = 0; j < texCache.groups.Size(); j++ ) {
						//vector2 newActorXY = ( l.linedef.v1.p + l.linedef.v2.p ) / 2;
						//vector3 newActorPos = ( newActorXY.x, newActorXY.y, ( l.sector.ceilingplane.d - l.sector.floorplane.d ) / 2 );
						//texCache.groups[ j ].SpawnActor( newActorPos );

						texCache.groups[ j ].SpawnActor( l, curSidePos );
					}*/

					// Here must be a use frequency list, really.
					for ( int j = 0; j < textures.Size(); j++ ) {
						if ( textures[ j ].id == texID ) {
							// Chain call to groups linked to the texture:
							for ( int i = 0; i < textures[ j ].groups.Size(); i++ )
								textures[ j ].groups[ i ].SpawnActor( l, curSidePos, textures[ j ], i );

							break;
						}
					}

				} // of if ( texID ) {

			} // of for ( int i = 0; i < 2; i++ ) {

		} // of for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {


		Super.WorldLoaded( e );
	} // of override void WorldLoaded( WorldEvent e ) {

} // of class AmbientHandler: EventHandler {


/*class AutoAmbientActor_Comp: Actor {
	States {
	Spawn:
		TNT1 A 0;
		TNT1 A 1 A_SetTics( Random( 0, 29 ) );
		TNT1 A 0 A_Jump( 127, "Spawn2" );
		TNT1 A 30 A_PlaySound( "AA/Computers/Beep", CHAN_AUTO, 0.2, false, 4 );
		Wait;
	}
}*/
