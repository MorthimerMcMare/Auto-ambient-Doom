version "2.4.0"

#include "ZScript/DataClasses.zsc"
#include "ZScript/AutoActors.zsc"
#include "ZScript/ConfigParser.zsc"


enum EAutoAmbientSoundModes {
	AASM_Looped = 0,
	AASM_Fixed,
	AASM_Random
};

enum EAutoAmbientSamelineCheck {
	AASC_On,
	AASC_Off,
	AASC_Only,

	AASC_Default = AASC_On
};

enum EAutoAmbientActionlineCheck {
	AAAC_On = 0,
	AAAC_Off,
	AAAC_Only,
	AAAC_AlsoZeroHeight,

	AAAC_Default = AAAC_On
};

enum EAutoAmbientLinesCheckFlags {
	AALCF_CommonLine			= 0x0001,
	AALCF_CommonLineZeroHeight	= 0x0002,
	AALCF_ActionLine			= 0x0004,
	AALCF_ActionLineZeroHeight	= 0x0008,
	AALCF_SelfLineDistCheck		= 0x0010,
	AALCF_OtherLinesDistCheck	= 0x0020,

	AALCF_Default = AALCF_CommonLine | AALCF_ActionLine | AALCF_SelfLineDistCheck | AALCF_OtherLinesDistCheck,

	AALCF_Error = 0xFFFF
};



class AutoAmbientGlobalHandler: StaticEventHandler {
	const AutoAmbientHandlerOrder = 0x7FAA0004;

	const replicateParserMaxAmount = 16;
	int replicateParserAmount; // To prevent infinite recursive including loop.
	int parserErrorLine;
	String parserErrorFilename;

	Array<AutoAmbientTexture> textures;
	Array<AutoAmbientGroup> groups;
	Array<AutoAmbientTextureParameter> textureparams;
	Array<AutoAmbientSoundDefinition> sounddefs;

	Array<AutoAmbientCacheTexture> texcache; // Just a list which must be ordered by level use frequency.

	static AutoAmbientGlobalHandler Get( void ) {
		return AutoAmbientGlobalHandler( StaticEventHandler.Find( "AutoAmbientGlobalHandler" ) );
	}


	bool CheckReplicateParserAmount( void ) {
		bool outValue = false;

		if ( replicateParserMaxAmount < replicateParserMaxAmount ) {
			replicateParserAmount++;
			outValue = true;
		}

		return outValue;
	}

	AutoAmbientTexture FindInvalidTexture( void ) {
		for ( int i = 0; i < textures.Size(); i++ )
			if ( !textures[ i ].Validate() )
				return textures[ i ];

		return NULL;
	}

	// Configuration init/file parser:
	override void OnRegister() {
		SetOrder( AutoAmbientHandlerOrder );

		textures.Clear();
		groups.Clear(); 
		textureparams.Clear();
		sounddefs.Clear();

		texcache.Clear();

		/*lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Pipe", 256 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Pipes", vol: 0.4, attn: 4.5 );
		AddTexture( "BROWNPIP" );
		AddTexture( "METAL4" );
		AddTexture( "PIPE2" );
		AddTexture( "PIPE6" );
		AddTexture( "PIPEWAL1" );
		AddTexture( "PIPES" );
		AddTexture( "SW1PIPE" );
		AddTexture( "SW2PIPE" );
		AddTexture( "TEKGREN4" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Comp", 128 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Computers/Beep", AASM_Fixed, 0.4, 5.0, 35 );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Computers/Boop", AASM_Fixed, 0.4, 5.0, 35 );
		//groups[ lastGroupIndex ].AddClass( "AutoAmbientActor_Comp" );
		AddTexture( "COMPSTA1" );
		AddTexture( "COMPSTA2" );
		AddTexture( "COMPTALL", start: ( 32.0, 64.0 ), offset: ( 96.0, 0.0 ) );
		AddTexture( "SILVER3" );
		AddTexture( "SPACEW3", ( 32.0, 32.0 ), ( 64.0, 64.0 ), ( 0.0, 24.0 ) );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Tech", 192 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Tech", vol: 0.7, attn: 3.5 );
		AddTexture( "CEMENT2" );
		AddTexture( "CEMENT4" );
		AddTexture( "ICKWALL4" );
		AddTexture( "SW1COMP" );
		AddTexture( "SW2COMP" );
		AddTexture( "COMPTALL" );
		AddTexture( "COMPWERD" );
		AddTexture( "TEKGREN1" );
		AddTexture( "TEKWALL1" );
		AddTexture( "TEKWALL4" );
		AddTexture( "TEKWALL6" );
		AddTexture( "ZZZFACE6" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "BloodPipe", 96 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/BloodPipes", vol: 0.6, attn: 4.2 );
		AddTexture( "BLODRIP1" );
		AddTexture( "BLODRIP2" );
		AddTexture( "BLODRIP3" );
		AddTexture( "BLODRIP4" );
		AddTexture( "PIPE1" );
		AddTexture( "SK_LEFT" );
		AddTexture( "SK_RIGHT" );
		AddTexture( "SLOPPY2" );*/

		AutoAmbientConfigParser.Create( self ).ParseFile( "aambient.cfg" );

		if ( !parserErrorLine )
			console.printf( GetClassName() .. "::OnRegister(). Loading configuration done." );
		else
			console.printf( GetClassName() .. "::OnRegister(). Error during configuration files parsing in " .. parserErrorFilename .. " on line " .. parserErrorLine .. "." );

		Super.OnRegister();
	}


	override void WorldLoaded( WorldEvent e ) {
		bool dontLoadAutoAmbient = false;

		// Some checks which prevents second large part from loading:
		if ( e.IsSaveGame || ( parserErrorLine != 0 ) ) {
			dontLoadAutoAmbient = true;
		} else if ( !groups.Size() ) {
			console.printf( GetClassName() .. "::WorldLoaded(). No group blocks provided in the configuration file." );
			dontLoadAutoAmbient = true;
		} else if ( !textures.Size() ) {
			console.printf( GetClassName() .. "::WorldLoaded(). No texture definition blocks provided in the configuration file." );
			dontLoadAutoAmbient = true;
		} else {
			AutoAmbientTexture invalidTexture = FindInvalidTexture();

			if ( invalidTexture ) {
				dontLoadAutoAmbient = true;
				console.printf( GetClassName() .. "::WorldLoaded(). ERROR: texture definition ID " .. invalidTexture.id .. " is not valid." );
				console.printf( GetClassName() .. "::WorldLoaded(). Validate callback: " 
								.. "id=" .. TexMan.GetName( invalidTexture.id ) .. ", size.Length()=" .. invalidTexture.size.Length() 
								.. ", groups.Size()=" .. invalidTexture.groups.Size() .. ", groupparams.Size()=" .. !invalidTexture.groupparams.Size() 
								.. ", addingErrorFlag=" .. invalidTexture.invalidFlag );
			}
		}

		if ( dontLoadAutoAmbient ) {
			Super.WorldLoaded( e );
			return;
		}



		// Static event handler may save information through levels.
		for ( int i = 0; i < groups.Size(); i++ )
			groups[ i ].ClearSpawned();

		/*for ( int i = 0; i < textures.Size(); i++ ) {
			String debugGroups = "TEX " .. textures[ i ].id .. ":";
			AutoAmbientTexture curdebugtex = textures[ i ];
			for ( int j = 0; j < curdebugtex.groups.Size(); j++ )
				debugGroups = debugGroups .. " " .. curdebugtex.groups[ j ].name;

			console.printf( debugGroups );
		}*/


		// A-a-argh! Seven nested "for" cycles in worst case!..
		//(Alright, it's non-exponential dependence, most of them has from one 
		//to three iterations).
		for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {
			Side l = level.Sides[ curSideIndex ];

			for ( int curSidePos = Side.top; curSidePos <= Side.bottom; curSidePos++ ) {
				TextureID texID = l.GetTexture( curSidePos );

				if ( texID ) {
					//console.printf( "Texture \"" .. TexMan.GetName( texID ) .. "\"." );
					AutoAmbientCacheTexture cachedTexture = NULL;

					// Here must be a use frequency list, really.

					// Attempt to find texture in cache array:
					for ( int j = 0; j < texcache.Size(); j++ ) {
						if ( texcache[ j ].texID == texID ) {
							cachedTexture = texcache[ j ];
							texcache[ j ].frequency++;

							// Ordering by use frequency:
							/*if ( j > 0 && groupcache[ j ].frequency > groupcache[ j - 1 ].frequency ) {
								// Really slow executing caused by universality.
								//Moreover, lines below will swap only neighbour
								//elements ("2, 1, 1, 2" -> "2, 1, 2, 1").
								groupcache.Insert( j - 1, groupcache[ j ] );
								groupcache.Delete( j + 1, 1 );
							} */
							break;
						}
					} // of for ( int j = 0; j < groupcache.Size(); j++ ) {}

					// Creating new texture cache if necessary:
					if ( !cachedTexture ) {
						cachedTexture = new( 'AutoAmbientCacheTexture' );
						cachedTexture.texID = texID;
						cachedTexture.frequency = 1;
						cachedTexture.texdef = NULL; // Texture may has no defined ambient actors.

						for ( int j = 0; j < textures.Size(); j++ )
							if ( textures[ j ].id == texID ) {
								cachedTexture.texdef = textures[ j ];
								break;
							}

						texcache.Push( cachedTexture );
					}

					// Spawning actor(s) according to the cached groups:
					AutoAmbientTexture curtexdef = cachedTexture.texdef;

					if ( curtexdef ) {
						for ( int j = 0; j < curtexdef.groups.Size(); j++ )
							curtexdef.groups[ j ].SpawnActor( l, curSidePos, curtexdef, j );
					}

				} // of if ( texID ) {}

			} // of for ( int curSidePos = 0; curSidePos < 2; curSidePos++ ) {}

		} // of for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {}


		Super.WorldLoaded( e );
	} // of override void WorldLoaded( WorldEvent e ) {}

} // of class AmbientHandler: EventHandler {}
