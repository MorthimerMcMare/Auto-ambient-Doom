version "2.4.0"

#include "ZScript/DataClasses.zsc"
#include "ZScript/AutoActors.zsc"

enum EAutoAmbientSoundModes {
	AASM_Looped = 0,
	AASM_Fixed,
	AASM_Random
};

enum EAutoAmbientSamelineCheck {
	AASC_On,
	AASC_Off,
	AASC_Only,

	AASC_Default = AASC_On
};

enum EAutoAmbientActionlineCheck {
	AAAC_Yes = 0,
	AAAC_Ignore,
	AAAC_AlsoZeroHeight,

	AAAC_Default = AAAC_Yes
};

enum EAutoAmbientParserBlocks {
	AAPB_Global = 0,
	AAPB_Texture,
	AAPB_TexParam,
	AAPB_Group,
	AAPB_Sound,

	AAPB_TextureParam = AAPB_TexParam,
	AAPB_TextureParameter = AAPB_TexParam,
	AAPB_SoundActor = AAPB_Sound,
	AAPB_SoundDef = AAPB_Sound
};


class AutoAmbientHandler: StaticEventHandler {
	const AutoAmbientHandlerOrder = 0x7FAA0003;

	Array<AutoAmbientTexture> textures;
	Array<AutoAmbientGroup> groups;
	Array<AutoAmbientCacheTexture> texcache; // Just a list which must be ordered by use frequency.

	// Temporary methods, just for convenience.
	int lastGroupIndex;
	void AddExtraGroupToTexture( AutoAmbientTexture tex, uint groupIndex, vector2 start = ( -1.0, -1.0 ), vector2 offset = ( -1.0, -1.0 ), vector2 rnd = ( 0.0, 0.0 ) ) {
		AutoAmbientTextureParameter newtexparam = AutoAmbientTextureParameter.Create( "temp", start, offset, rnd, 1.0 );
		tex.AddGroupParam( groups[ groupIndex ], newtexparam );
	}

	AutoAmbientTexture AddTexture( Name textureName, vector2 start = ( -1.0, -1.0 ), vector2 offset = ( -1.0, -1.0 ), vector2 rnd = ( 0.0, 0.0 ) ) {
		AutoAmbientTexture newtex = AutoAmbientTexture.Create( textureName );
		AddExtraGroupToTexture( newtex, lastGroupIndex, start, offset, rnd );
		uint lastpos = textures.Push( newtex );
		return textures[ lastpos ];
	}

	AutoAmbientTexture FindInvalidTexture( void ) {
		for ( int i = 0; i < textures.Size(); i++ )
			if ( !textures[ i ].Validate() )
				return textures[ i ];

		return NULL;
	}


	String aaConfigFile;
	int parserPos, aaConfigFileLength;

	EAutoAmbientParserBlocks parserCurBlockType;

	AutoAmbientTexture parserDefaultTexture, parserCurTexture;
	AutoAmbientTextureParameter parserDefaultTextureParam, parserCurTextureParam;
	AutoAmbientGroup parserDefaultGroup, parserCurGroup;
	AutoAmbientSoundDefinition parserDefaultSound, parserCurSound;

	String readNextWord( void ) {
		String word = "";
		String curChar = aaConfigFile.CharAt( parserPos );

		// Get rid of the empty symbols and comments before some meaningful word:
		do {
			// Comment skip ("\#.*\n"):
			if ( curChar == "#" )
				while ( parserPos < aaConfigFileLength && curChar.CharCodeAt( 0 ) != 10 )
					curChar = aaConfigFile.CharAt( ++parserPos );

			// Empty chars skip ("[ \t\n]"):
			while ( ( curChar == " " || curChar == "\t" || curChar == "\n" ) && parserPos < aaConfigFileLength )
				curChar = aaConfigFile.CharAt( ++parserPos );
		} while ( curChar == "#" && parserPos < aaConfigFileLength );

		if ( parserPos < aaConfigFileLength ) {
			bool quoted = false; // Phrase in "double quotes" is parsed as one word.

			if ( aaConfigFile.CharAt( parserPos ) == '"' ) {
				quoted = true;
				curChar = aaConfigFile.CharAt( ++parserPos );
			}

			while ( parserPos < aaConfigFileLength && ( quoted || ( curChar != " " && curChar != "\t" && curChar.CharCodeAt( 0 ) != 10 ) ) ) {
				//console.printf( "word \"" .. word .. "\", char[ " .. parserPos .. " ] = " .. curChar.CharCodeAt( 0 ) );

				if ( quoted && curChar == '"' ) {
					quoted ^= true;
				} else {
					word = word .. curChar;
				}

				curChar = aaConfigFile.CharAt( ++parserPos );
			}
		}

		return word;
	} // of String readNextWord( void ) {}


	bool ParseTextureBlock( String texname ) {
		return true;
	} // of bool ParseTextureBlock( String texname ) {}

	bool ParseTextureParameterBlock( String paramname ) {
		return true;
	} // of bool ParseTextureParameterBlock( String paramname ) {}

	bool ParseGroupBlock( String groupname ) {
		return true;
	} // of bool ParseGroupBlock( String groupname ) {}

	bool ParseSoundActorBlock( String actorname ) {
		return true;
	} // of bool ParseSoundActorBlock( String actorname ) {}

	bool ParseBlockHeader( void ) {
		bool successfulParsing = true;

		String identifier = readNextWord();
		String curWord = "";

		if ( readNextWord() == "{" ) { // '}' for the not clever colorer.
			switch ( parserCurBlockType ) {
				case AAPB_Texture:
					if ( identifier == "default" ) {
						parserCurTexture = parserDefaultTexture;
					} else {
						parserCurTexture = AutoAmbientTexture.Create( identifier );
						parserCurTexture.actionlineCheck = parserDefaultTexture.actionlineCheck;
						parserCurTexture.samelineCheck = parserDefaultTexture.samelineCheck;
					}

					while ( successfulParsing && ( curWord = readNextWord() ) != /*'{'*/ "}" )
						successfulParsing = ParseTextureBlock( curWord );
					break;
				case AAPB_TextureParameter:
					if ( identifier == "default" )
						parserCurTextureParam = parserDefaultTextureParam;
					else
						parserCurTextureParam = AutoAmbientTextureParameter.Create( identifier, parserDefaultTextureParam.start, parserDefaultTextureParam.offset, parserDefaultTextureParam.spreading, parserDefaultTextureParam.chance );

					while ( successfulParsing && ( curWord = readNextWord() ) != /*'{'*/ "}" )
						successfulParsing = ParseTextureParameterBlock( curWord );
					break;
				case AAPB_Group:
					if ( identifier == "default" )
						parserCurGroup = parserDefaultGroup;
					else
						parserCurGroup = AutoAmbientGroup.Create( identifier, parserDefaultGroup.actorsDistance );

					while ( successfulParsing && ( curWord = readNextWord() ) != /*'{'*/ "}" )
						successfulParsing = ParseGroupBlock( curWord );
					break;
				case AAPB_SoundDef:
					if ( identifier == "default" ) {
						parserCurSound = parserDefaultSound;
					} else {
						parserCurSound = AutoAmbientSoundDefinition.Create( "null", 
								parserDefaultSound.sndMode, parserDefaultSound.sndVolume, parserDefaultSound.sndAttenuation,
								parserDefaultSound.minDelay, parserDefaultSound.maxDelay );
					}

					while ( successfulParsing && ( curWord = readNextWord() ) != /*'{'*/ "}" )
						successfulParsing = ParseSoundActorBlock( curWord );
					break;
				case AAPB_Global:
					console.printf( GetClassName() .. "::ParseBlockHeader(). Impossible parser block type \"Global\"." );
					successfulParsing = false;
					break;
				default:
					console.printf( GetClassName() .. "::ParseBlockHeader(). Unrecognized parser block type " .. parserCurBlockType .. "." );
					successfulParsing = false;
					break;
			}
		} else {
			console.printf( GetClassName() .. "::ParseBlockHeader(). '{' after \"" .. identifier .. "\" expected." ); // '}' for the not clever colorer.
			successfulParsing = false;
		}

		return successfulParsing;
	} // of bool ParseBlockHeader( void ) {}

	bool ParseGlobalScope( void ) {
		bool successfulParsing = true;

		String curWord = readNextWord();
		//console.printf( GetClassName() .. "::ParseGlobalScope(). Parsed word \"" .. curWord .. "\"." );

		if ( curWord == "include" ) {
			ParseFile( readNextWord() );
			parserCurBlockType = AAPB_Global;
		} else if ( curWord == "texture" ) {
			parserCurBlockType = AAPB_Texture;
			ParseBlockHeader();
		} else if ( curWord == "textureparam" ) {
			parserCurBlockType = AAPB_TexParam;
			ParseBlockHeader();
		} else if ( curWord == "group" ) {
			parserCurBlockType = AAPB_Group;
			ParseBlockHeader();
		} else if ( curWord == "soundactor" ) {
			parserCurBlockType = AAPB_SoundDef;
			ParseBlockHeader();
		} else if ( curWord != "" ) {
			console.printf( GetClassName() .. "::ParseGlobalScope(). Unknown keyword \"" .. curWord .. "\"" );
			successfulParsing = false;
		}

		return successfulParsing;
	} // of bool ParseGlobalScope( void ) {}


	bool ParseFile( String filename ) {
		bool successfulParsing = true;

		int configFileHandler = Wads.FindLump( filename );

		// "AAmbient.cfg" file unparsing:
        if ( configFileHandler != -1 ) {
			console.printf( GetClassName() .. "::ParseFile(). Parsing file \"" .. filename .. "\"." );
			parserPos = 0;
            aaConfigFile = Wads.ReadLump( configFileHandler );

            aaConfigFile.ToLower();
            aaConfigFile.Replace( "\r", "\n" ); // "dos2unix", "mac2unix"...
			aaConfigFileLength = aaConfigFile.Length();

			parserCurBlockType = AAPB_Global;

			while ( parserPos < aaConfigFileLength && successfulParsing ) {
				successfulParsing = ParseGlobalScope();
			} // of while ( parserPos < aaConfigFileLength ) {}

        } else {
			console.printf( GetClassName() .. "::ParseFile(). Cannot find file \"" .. filename .. "\"." );
			successfulParsing = false;
		}

		return successfulParsing;
	} // of bool ParseFile( String filename ) {}

	// Configuration init/file parser:
	override void OnRegister() {
		SetOrder( AutoAmbientHandlerOrder );

		lastGroupIndex = -1;
		textures.Clear();
		groups.Clear(); 
		texcache.Clear();

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Pipe", 256 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Pipes", vol: 0.4, attn: 4.5 );
		AddTexture( "BROWNPIP" );
		AddTexture( "METAL4" );
		AddTexture( "PIPE2" );
		AddTexture( "PIPE6" );
		AddTexture( "PIPEWAL1" );
		AddTexture( "PIPES" );
		AddTexture( "SW1PIPE" );
		AddTexture( "SW2PIPE" );
		AddTexture( "TEKGREN4" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Comp", 128 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Computers/Beep", AASM_Fixed, 0.4, 5.0, 35 );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Computers/Boop", AASM_Fixed, 0.4, 5.0, 35 );
		//groups[ lastGroupIndex ].AddClass( "AutoAmbientActor_Comp" );
		AddTexture( "COMPSTA1" );
		AddTexture( "COMPSTA2" );
		AddTexture( "COMPTALL", start: ( 32.0, 64.0 ), offset: ( 96.0, 0.0 ) );
		AddTexture( "SILVER3" );
		AddTexture( "SPACEW3", ( 32.0, 32.0 ), ( 64.0, 64.0 ), ( 0.0, 24.0 ) );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Tech", 192 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Tech", vol: 0.7, attn: 3.5 );
		AddTexture( "CEMENT2" );
		AddTexture( "CEMENT4" );
		AddTexture( "ICKWALL4" );
		AddTexture( "SW1COMP" );
		AddTexture( "SW2COMP" );
		AddTexture( "COMPTALL" );
		AddTexture( "COMPWERD" );
		AddTexture( "TEKGREN1" );
		AddTexture( "TEKWALL1" );
		AddTexture( "TEKWALL4" );
		AddTexture( "TEKWALL6" );
		AddTexture( "ZZZFACE6" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "BloodPipe", 96 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/BloodPipes", vol: 0.6, attn: 4.2 );
		AddTexture( "BLODRIP1" );
		AddTexture( "BLODRIP2" );
		AddTexture( "BLODRIP3" );
		AddTexture( "BLODRIP4" );
		AddTexture( "PIPE1" );
		AddTexture( "SK_LEFT" );
		AddTexture( "SK_RIGHT" );
		AddTexture( "SLOPPY2" );

		parserDefaultTexture = new( 'AutoAmbientTexture' );
		parserDefaultTexture.actionlineCheck = AAAC_Default;
		parserDefaultTexture.samelineCheck = AASC_Default;
		parserDefaultTextureParam = AutoAmbientTextureParameter.Create( "Default texture parameter", ( -50.0, -50.0 ), ( -100.0, -100.0 ), ( 0.0, 0.0 ), 1.0 );
		parserDefaultGroup = AutoAmbientGroup.Create( "Default group", 256 );
		parserDefaultSound = AutoAmbientSoundDefinition.Create( "Default sound definition", AASM_Looped, 1.0, 1.0, 35, 35 );

		parserCurTexture = NULL;
		parserCurTextureParam = NULL;
		parserCurGroup = NULL;
		parserCurSound = NULL;

		if ( ParseFile( "aambient.cfg" ) )
			console.printf( GetClassName() .. "::OnRegister(). Loading configuration done." );
		else
			console.printf( GetClassName() .. "::OnRegister(). An error occured during configuration file parsing." );

		Super.OnRegister();
	}


	override void WorldLoaded( WorldEvent e ) {
		AutoAmbientTexture invalidTexture = FindInvalidTexture();

		if ( invalidTexture ) {
			console.printf( GetClassName() .. "::WorldLoaded(). ERROR: texture definition ID " .. invalidTexture.id .. " is not valid." );
			console.printf( GetClassName() .. "::WorldLoaded(). Texture name: " .. TexMan.GetName( invalidTexture.id ) );
			Super.WorldLoaded( e );

			return;
		}

		// Static event handler may save information through levels.
		for ( int i = 0; i < groups.Size(); i++ )
			groups[ i ].ClearSpawned();


		// A-a-argh! Seven nested "for" cycles in worst case!..
		//(Alright, it's non-exponential dependence, most of them has from one 
		//to three iterations).
		for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {
			Side l = level.Sides[ curSideIndex ];

			for ( int curSidePos = 0; curSidePos < 2; curSidePos++ ) {
				TextureID texID = l.GetTexture( curSidePos );

				if ( texID ) {
					//console.printf( "Texture \"" .. TexMan.GetName( texID ) .. "\"." );
					AutoAmbientCacheTexture cachedTexture = NULL;

					// Here must be a use frequency list, really.

					// Attempt to find texture in cache array:
					for ( int j = 0; j < texcache.Size(); j++ ) {
						if ( texcache[ j ].texID == texID ) {
							cachedTexture = texcache[ j ];
							texcache[ j ].frequency++;

							// Ordering by use frequency:
							/*if ( j > 0 && groupcache[ j ].frequency > groupcache[ j - 1 ].frequency ) {
								// Really slow executing caused by universality.
								//Moreover, lines below will swap only neighbour
								//elements ("2, 1, 1, 2" -> "2, 1, 2, 1").
								groupcache.Insert( j - 1, groupcache[ j ] );
								groupcache.Delete( j + 1, 1 );
							} */
							break;
						}
					} // of for ( int j = 0; j < groupcache.Size(); j++ ) {}

					// Creating new texture cache if necessary:
					if ( !cachedTexture ) {
						cachedTexture = new( 'AutoAmbientCacheTexture' );
						cachedTexture.texID = texID;
						cachedTexture.frequency = 1;
						cachedTexture.texdef = NULL; // Texture may has no defined ambient actors.

						for ( int j = 0; j < textures.Size(); j++ )
							if ( textures[ j ].id == texID ) {
								cachedTexture.texdef = textures[ j ];
								break;
							}

						texcache.Push( cachedTexture );
					}

					// Spawning actor(s) according to the cached groups:
					AutoAmbientTexture curtexdef = cachedTexture.texdef;

					if ( curtexdef ) {
						for ( int j = 0; j < curtexdef.groups.Size(); j++ )
							curtexdef.groups[ j ].SpawnActor( l, curSidePos, curtexdef, j );
					}

				} // of if ( texID ) {}

			} // of for ( int curSidePos = 0; curSidePos < 2; curSidePos++ ) {}

		} // of for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {}


		Super.WorldLoaded( e );
	} // of override void WorldLoaded( WorldEvent e ) {}

} // of class AmbientHandler: EventHandler {}
