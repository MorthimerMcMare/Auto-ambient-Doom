version "2.4.0"

class AutoAmbientSoundDefinition {
	Sound snd;
	double sndVolume, sndAttenuation;
	EAutoAmbientSoundModes sndMode;
	uint minDelay, maxDelay;

	static AutoAmbientSoundDefinition Create( Sound initSnd, EAutoAmbientSoundModes initMode, double initVolume, double initAttn, uint initMinDelay, uint initMaxDelay ) {
		AutoAmbientSoundDefinition newDef = new( 'AutoAmbientSoundDefinition' );

		newDef.snd = initSnd;
		newDef.sndMode = initMode;
		newDef.sndVolume = initVolume;
		newDef.sndAttenuation = initAttn;
		newDef.minDelay = initMinDelay;
		newDef.maxDelay = initMaxDelay;

		return newDef;
	}
} // of class AutoAmbientSoundDefinition {

class AutoAmbientGroup play {
	String name;
	Array< class<Actor> > classes;
	Array<AutoAmbientSoundDefinition> autoclasses;
	Array<TextureID> textures;
	double actorsDistance;
	double actorsSpreading;
	EAutoAmbientSoundModes mode;

	TextureID cachedTexture;

	Array<Actor> actors;

	static AutoAmbientGroup Create( String groupname, double dist, double spreading ) {
		AutoAmbientGroup newGroup = new( 'AutoAmbientGroup' );

		newGroup.name = groupname;
		newGroup.actorsDistance = dist;
		newGroup.actorsSpreading = spreading;
		//newGroup.cachedTexture = 0;

		return newGroup;
	}

	// See GZDoom source code, "/src/common/textures/textureid.h" ("class FTextureID").
	//TextureID comparing is really much faster than same for String.
	bool IsTextureInGroup( TextureID texID ) {
		// At least something (in my opinion about 20%) will be speeded up.
		if ( texID == cachedTexture )
			return true;

		for ( int i = 0; i < textures.Size(); i++ ) {
			if ( texID == textures[ i ] ) {
				cachedTexture = texID;
				return true;
			}
		}

		return false;
	} // of bool IsTextureInGroup( TextureID texID ) {

	bool AddClass( class<Actor> cls ) {
		if ( cls )
			classes.Push( cls );

		return !!cls;
	}

	bool AddAutoSoundClass( Sound snd, EAutoAmbientSoundModes mode = AASM_Looping, double vol = 1.0, double attn = 1.0, uint delay1 = 0, uint delay2 = 35 ) {
		AutoAmbientSoundDefinition newclass = AutoAmbientSoundDefinition.Create( snd, mode, vol, attn, delay1, delay2 );

		if ( newclass )
			autoclasses.Push( newclass );

		return !!newclass;
	}

	bool AddTexture( String textureName ) {
		TextureID addeeTex = TexMan.CheckForTexture( textureName, TexMan.Type_Wall );

		if ( addeeTex ) {
			// Dirty hack. But ZScript cannot push TextureID to the 
			//Array<TextureID> due to special class logic.
			textures.Push( 0 );
			textures[ textures.Size() - 1 ] = addeeTex;
		}

		return !!addeeTex;
	}

	void SpawnActor( vector3 actorpos /*Line attachLine*/ ) {
		Actor newActor = NULL;

		// Get a random class from the (auto)classes arrays:
		uint classesSize = classes.Size();
		uint rnd = Random( 0, classesSize + autoclasses.Size() - 1 );

		//console.printf( "rnd: " .. rnd .. ", c.Size(): " .. classesSize .. ", ac.Size(): " .. autoclasses.Size() );

		if ( rnd < classesSize ) {
			newActor = Actor.Spawn( classes[ rnd ], actorpos );
		} else if ( autoclasses.Size() ) {
			newActor = Actor.Spawn( "AutoAmbientSoundActor", actorpos );
			AutoAmbientSoundActor( newActor ).Init( autoclasses[ rnd - classesSize ] );
		}

		if ( newActor ) {
			bool grouplingTooClose = false; // Same mean as in word "Sibling".

			// Maybe it's better to get rid of this check from the main cycle.
			for ( int i = 0; i < actors.Size(); i++ ) {
				//console.printf( "#" .. i .. ". actors.Size(): " .. actors.Size() .. ", newActor: " .. newActor .. ", actors[ i ]: " .. actors[ i ]  );

				if ( newActor.Distance2D( actors[ i ] ) < actorsDistance ) {
					grouplingTooClose = true;
					break;
				}
			}

			if ( grouplingTooClose ) {
				newActor.Destroy();
			} else if ( newActor ) {
				if ( actorsSpreading != 0.0 )
					newActor.SetOrigin( newActor.pos + ( FRandom( -actorsSpreading, actorsSpreading ), FRandom( -actorsSpreading, actorsSpreading ), 0 ), false );

				actors.Push( newActor );
				console.printf( "Actor from group " .. self.name .. " spawned at " .. newActor.pos );
			}
		} // of if ( newActor ) {
	} // of void SpawnActor( vector3 pos ) {

} // of class AutoAmbientGroup {


class AutoAmbientGroupCache {
	TextureID texture;
	Array<AutoAmbientGroup> groups;
	uint frequency;
}

class AutoAmbientHandler: EventHandler {
	const AutoAmbientHandlerOrder = 0x7FAA0003;

	Array<AutoAmbientGroup> groups;
	Array<AutoAmbientGroupCache> groupcache; // Just a list ordered by use frequency.

	override void OnRegister() {
		SetOrder( AutoAmbientHandlerOrder );

		groups.Push( AutoAmbientGroup.Create( "Comp", 128, 32 ) );
		//groups[ 0 ].AddClass( "AutoAmbientActor_Comp" );
		groups[ 0 ].AddAutoSoundClass( "AA/Computers/Beep", AASM_Fixed, 0.4, 5.0, 35 );
		groups[ 0 ].AddAutoSoundClass( "AA/Computers/Boop", AASM_Fixed, 0.4, 5.0, 35 );
		groups[ 0 ].AddTexture( "COMPSTA1" );
		groups[ 0 ].AddTexture( "COMPSTA2" );
		groups[ 0 ].AddTexture( "COMPTALL" );
		groups[ 0 ].AddTexture( "SILVER3" );
		groups[ 0 ].AddTexture( "SPACEW3" );

		groups.Push( AutoAmbientGroup.Create( "Pipe", 256, 0 ) );
		groups[ 1 ].AddAutoSoundClass( "AA/Pipes", vol: 0.4, attn: 4 );
		groups[ 1 ].AddTexture( "BROWNPIP" );
		groups[ 1 ].AddTexture( "METAL4" );
		groups[ 1 ].AddTexture( "METAL4" );
		groups[ 1 ].AddTexture( "PIPE2" );
		groups[ 1 ].AddTexture( "PIPE6" );
		groups[ 1 ].AddTexture( "PIPEWAL1" );
		groups[ 1 ].AddTexture( "PIPES" );
		groups[ 1 ].AddTexture( "SW1PIPE" );
		groups[ 1 ].AddTexture( "SW2PIPE" );
		groups[ 1 ].AddTexture( "TEKGREN4" );
		groups[ 1 ].AddTexture( "ZZZFACE5" );
		groups[ 1 ].AddTexture( "ZZZFACE7" );
		groups[ 1 ].AddTexture( "ZZZFACE8" );

		groups.Push( AutoAmbientGroup.Create( "Tech", 192, 24 ) );
		groups[ 2 ].AddAutoSoundClass( "AA/Tech", vol: 0.6, attn: 3.5 );
		groups[ 2 ].AddTexture( "CEMENT2" );
		groups[ 2 ].AddTexture( "CEMENT4" );
		groups[ 2 ].AddTexture( "ICKWALL4" );
		groups[ 2 ].AddTexture( "SW1COMP" );
		groups[ 2 ].AddTexture( "SW2COMP" );
		groups[ 2 ].AddTexture( "COMPTALL" );
		groups[ 2 ].AddTexture( "COMPWERD" );
		groups[ 2 ].AddTexture( "TEKGREN1" );
		groups[ 2 ].AddTexture( "TEKWALL1" );
		groups[ 2 ].AddTexture( "TEKWALL4" );
		groups[ 2 ].AddTexture( "TEKWALL6" );
		groups[ 2 ].AddTexture( "ZZZFACE6" );

		groups.Push( AutoAmbientGroup.Create( "BloodPipe", 128, 0 ) );
		groups[ 3 ].AddAutoSoundClass( "AA/BloodPipes", vol: 0.6, attn: 4.2 );
		groups[ 3 ].AddTexture( "BLODRIP1" );
		groups[ 3 ].AddTexture( "BLODRIP2" );
		groups[ 3 ].AddTexture( "BLODRIP3" );
		groups[ 3 ].AddTexture( "BLODRIP4" );
		groups[ 3 ].AddTexture( "PIPE1" );
		groups[ 3 ].AddTexture( "SK_LEFT" );
		groups[ 3 ].AddTexture( "SK_RIGHT" );
		groups[ 3 ].AddTexture( "SLOPPY2" );

		Super.OnRegister();
	}

	override void WorldLoaded( WorldEvent e ) {

		// A-a-argh! Five nested "for" cycles in worst case!..
		for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {
			Side l = level.Sides[ curSideIndex ];

			for ( int i = 0; i < 2; i++ ) {
				TextureID texID = l.GetTexture( i );

				if ( texID ) {
					//console.printf( "Texture \"" .. TexMan.GetName( texID ) .. "\"." );
					AutoAmbientGroupCache texCache = NULL;

					// Attempt to find texture in cache array:
					for ( int j = 0; j < groupcache.Size(); j++ ) {
						if ( groupcache[ j ].texture == texID ) {
							texCache = groupcache[ j ];
							groupcache[ j ].frequency++;

							// Ordering by use frequency:
							/*if ( j > 0 && groupcache[ j ].frequency > groupcache[ j - 1 ].frequency ) {
								// Really slow executing caused by universality.
								//Moreover, lines below will swap only neighbour
								//elements ("2, 1, 1, 2" -> "2, 1, 2, 1").
								groupcache.Insert( j - 1, groupcache[ j ] );
								groupcache.Delete( j + 1, 1 );
							}*/
							break;
						}
					} // of for ( int j = 0; j < groupcache.Size(); j++ ) {

					// Creating new texture cache if necessary:
					if ( !texCache ) {
						texCache = new( 'AutoAmbientGroupCache' );
						texCache.texture = texID;
						texCache.frequency = 1;

						// Different groups may handle one texture.
						for ( int j = 0; j < groups.Size(); j++ ) {
							if ( groups[ j ].IsTextureInGroup( texID ) )
								texCache.groups.Push( groups[ j ] );
						}

						groupcache.Push( texCache );
					}

					// Spawning actor(s) according to the cached groups:
					for ( int j = 0; j < texCache.groups.Size(); j++ ) {
						vector2 newActorXY = ( l.linedef.v1.p + l.linedef.v2.p ) / 2;
						vector3 newActorPos = ( newActorXY.x, newActorXY.y, ( l.sector.ceilingplane.d - l.sector.floorplane.d ) / 2 );

						texCache.groups[ j ].SpawnActor( newActorPos );
					}
				} // of if ( texID ) {

			} // of for ( int i = 0; i < 2; i++ ) {

		} // of for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {


		Super.WorldLoaded( e );
	} // of override void WorldLoaded( WorldEvent e ) {

} // of class AmbientHandler: EventHandler {


/*class AutoAmbientActor_Comp: Actor {
	States {
	Spawn:
		TNT1 A 0;
		TNT1 A 1 A_SetTics( Random( 0, 29 ) );
		TNT1 A 0 A_Jump( 127, "Spawn2" );
		TNT1 A 30 A_PlaySound( "AA/Computers/Beep", CHAN_AUTO, 0.2, false, 4 );
		Wait;
	}
}*/


enum EAutoAmbientSoundModes {
	AASM_Looping = 0,
	AASM_Fixed,
	AASM_Random
};

class AutoAmbientSoundActor: Actor {
	AutoAmbientSoundDefinition def;
	bool actorInitialized; // Call "Init()" with right arguments to set it up.

	// Here are stored the most used and local variables:
	EAutoAmbientSoundModes playsoundMode;
	uint minDelay, maxDelay, curDelay;


	Default {
		+NOINTERACTION;
		+NOBLOCKMAP;
		+INVISIBLE;
	}

	void Init( AutoAmbientSoundDefinition initDef ) {
		def = initDef;

		actorInitialized = ( def && ( def.snd != "" ) );

		if ( actorInitialized ) {
			playsoundMode = def.sndMode;

			switch ( playsoundMode ) {
				case AASM_Looping:
					break;
				case AASM_Fixed:
					minDelay = maxDelay = def.minDelay;
					break;
				case AASM_Random:
					minDelay = def.minDelay;
					maxDelay = def.maxDelay;
					break;
				default:
					console.printf( "Error: cannot init actor, sound mode " .. playsoundMode .. " isn't recognized." );
					actorInitialized = false;
					break;
			}
		}
	} // of void Init( EAutoAmbientSoundModes mode, Sound soundToPlay, double volume = 1.0, double attn = 1.0, uint delay1 = 0, uint delay2 = 0 ) {


	override void PostBeginPlay() {
		Super.PostBeginPlay();

		if ( actorInitialized ) {
			curDelay = Random( 0, ( (playsoundMode == AASM_Looping)? 5 : maxDelay ) );
		} else {
			console.printf( "Actor " .. GetClassName() .. " <" .. self .. "> not initialized. Destroying self." );
			Destroy();
		}
	} // of override void PostBeginPlay() {

	override void Tick() {
		// Must not stop on globalfreeze.

		switch ( playsoundMode ) {
			case AASM_Fixed:
			case AASM_Random:
				if ( curDelay-- <= 0 ) {
					A_PlaySound( def.snd, CHAN_AUTO, def.sndVolume, false, def.sndAttenuation );
					//S_Sound( def.snd, CHAN_AUTO, def.sndVolume, def.sndAttenuation );
					curDelay = ( playsoundMode == AASM_Fixed )? minDelay : Random( minDelay, maxDelay );
				}
				break;
			case AASM_Looping: // Light randomization.
				if ( curDelay > 0 ) {
					curDelay--;
					A_PlaySound( def.snd, CHAN_AUTO, def.sndVolume, true, def.sndAttenuation );
				}
				break;
			default:
				break;
		}

		Super.Tick();
	} // of override void Tick() {

	States {
	Spawn:
		TNT1 A 0;
		TNT1 A -1;
		stop;
	}
} // of class AutoAmbientSoundActor: Actor {
