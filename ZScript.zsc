version "2.4.0"

#include "ZScript/DataClasses.zsc"
#include "ZScript/AutoActors.zsc"

enum EAutoAmbientSoundModes {
	AASM_Looped = 0,
	AASM_Fixed,
	AASM_Random
};

enum EAutoAmbientSamelineCheck {
	AASC_On,
	AASC_Off,
	AASC_Only,

	AASC_Default = AASC_On
};

enum EAutoAmbientActionlineCheck {
	AAAC_Yes = 0,
	AAAC_Ignore,
	AAAC_AlsoZeroHeight,

	AAAC_Default = AAAC_Yes
};

enum EAutoAmbientParserBlocks {
	AAPB_Global = 0,
	AAPB_Texture,
	AAPB_TexParam,
	AAPB_Group,
	AAPB_Sound,

	AAPB_TextureParam = AAPB_TexParam,
	AAPB_TextureParameter = AAPB_TexParam,
	AAPB_SoundActor = AAPB_Sound,
	AAPB_SoundDef = AAPB_Sound
};


class AutoAmbientHandler: StaticEventHandler {
	const AutoAmbientHandlerOrder = 0x7FAA0003;

	Array<AutoAmbientTexture> textures;
	Array<AutoAmbientTextureParameter> textureparams;
	Array<AutoAmbientSoundDefinition> sounddefs;
	Array<AutoAmbientGroup> groups;

	Array<AutoAmbientCacheTexture> texcache; // Just a list which must be ordered by use frequency.


	String aaConfigFile;
	Array<String> aaConfigLines;
	int parserLineNum;
	bool parserErrorFlag;
	Array<String> configFileLine; // One line from the configuration file, "getNextConfigLine()" stores the value here.

	EAutoAmbientParserBlocks parserCurBlockType;

	AutoAmbientTexture parserDefaultTexture, parserCurTexture;
	AutoAmbientTextureParameter parserDefaultTextureParam, parserCurTextureParam;
	AutoAmbientGroup parserDefaultGroup, parserCurGroup;
	AutoAmbientSoundDefinition parserDefaultSound, parserCurSound;



	AutoAmbientTexture FindInvalidTexture( void ) {
		for ( int i = 0; i < textures.Size(); i++ )
			if ( !textures[ i ].Validate() )
				return textures[ i ];

		return NULL;
	}

	AutoAmbientGroup FindGroup( String groupname ) {
		for ( int i = 0; i < groups.Size(); i++ )
			if ( groups[ i ].name == groupname )
				return groups[ i ];
		return NULL;
	}
	AutoAmbientTextureParameter FindTextureParam( String paramname ) {
		for ( int i = 0; i < textureparams.Size(); i++ )
			if ( textureparams[ i ].name == paramname )
				return textureparams[ i ];
		return NULL;
	}
	AutoAmbientSoundDefinition FindSoundDef( String sndname ) {
		for ( int i = 0; i < sounddefs.Size(); i++ )
			if ( sounddefs[ i ].name == sndname )
				return sounddefs[ i ];
		return NULL;
	}

	/*String readNextWord( void ) {
		String word = "";
		String curChar = aaConfigFile.CharAt( parserPos );

		// Get rid of the empty symbols and comments before some meaningful word:
		do {
			// Empty chars skip ("[ \t\n]"):
			while ( ( curChar == " " || curChar == "\t" || curChar.CharCodeAt( 0 ) == 10 ) && parserPos < aaConfigFileLength )
				curChar = aaConfigFile.CharAt( ++parserPos );

			// Comment skip ("\#.*\n"):
			if ( curChar == "#" )
				while ( parserPos < aaConfigFileLength && curChar.CharCodeAt( 0 ) != 10 )
					curChar = aaConfigFile.CharAt( ++parserPos );

			if ( curChar.CharCodeAt( 0 ) == 10 ) {
				parserLineNum++;
				curChar = aaConfigFile.CharAt( ++parserPos );
			}
		} while ( curChar == "#" && parserPos < aaConfigFileLength );
		//console.printf( "pos " .. parserPos .. "/" .. aaConfigFileLength .. ", curChar == " .. curChar );

		if ( parserPos < aaConfigFileLength ) {
			bool quoted = false; // Phrase in "double quotes" is parsed as one word.

			if ( aaConfigFile.CharAt( parserPos ) == '"' ) {
				quoted = true;
				curChar = aaConfigFile.CharAt( ++parserPos );
			}

			while ( parserPos < aaConfigFileLength && ( quoted || ( curChar != " " && curChar != "\t" && curChar.CharCodeAt( 0 ) != 10 ) ) ) {
				console.printf( "word \"" .. word .. "\", char[ " .. parserPos .. " ] = " .. curChar.CharCodeAt( 0 ) );

				if ( quoted && curChar == '"' ) {
					quoted ^= true;
				} else {
					word = word .. curChar;
				}

				curChar = aaConfigFile.CharAt( ++parserPos );
			}

			if ( curChar.CharCodeAt( 0 ) == 10 )
				parserLineNum++;
		}

		return word;
	} // of String readNextWord( void ) {}
	*/

	void readNextConfigLine( void ) {
		configFileLine.Clear();

		if ( ++parserLineNum < aaConfigLines.Size() ) {
			//int newlinePos = aaConfigFile.IndexOf( "\n", parserPos );
			//int parserPos = ( newlinePos != -1 )? ( newlinePos - parserPos ) : aaConfigFileLength;

			String tempstr = aaConfigLines[ parserLineNum ];
			int newlinePos = tempstr.IndexOf( "#" );

			if ( newlinePos != -1 )
				tempstr = tempstr.Left( newlinePos );

			tempstr.Replace( "\t", " " );
			// No quotes check now.
			tempstr.Split( configFileLine, " ", TOK_SKIPEMPTY );

			if ( configFileLine.Size() == 1 && configFileLine[ 0 ].CharCodeAt( 0 ) == 0 )
				configFileLine.Clear();

			//console.printf( "readNextConfigLine(). tempstr: \"" .. tempstr .. "\"." );
		}
	} // of void readNextConfigLine( void ) {}


	void ParserError( String msg ) {
		for ( int i = 0; i < configFileLine.Size(); i++ ) console.printf( "configFileLine[ " .. i .. " ] = " .. configFileLine[ i ] );

		console.printf( GetClassName() .. msg );
		parserErrorFlag = true;
	}

	void ParseTextureBlock( void ) {
		if ( configFileLine[ 0 ] == "group" ) {
			if ( configFileLine.Size() == 3 || configFileLine.Size() == 4 ) {
				AutoAmbientGroup texgroup = FindGroup( configFileLine[ 1 ] );

				if ( texgroup ) {
					if ( configFileLine.Size() == 3 ) {
						AutoAmbientTextureParameter texparam = FindTextureParam( configFileLine[ 2 ] );

						if ( texparam )
							parserCurTexture.AddGroupParam( texgroup, texparam );
						else
							ParserError( "::ParseTextureBlock(). \"group\": cannot find texture parameter name \"" .. configFileLine[ 1 ] .. "\"." );
					} else {
						parserCurTexture.AddGroup( texgroup, ( configFileLine[ 2 ].ToDouble(), configFileLine[ 3 ].ToDouble() ) );
					}
				} else {
					ParserError( "::ParseTextureBlock(). \"group\": cannot find group name \"" .. configFileLine[ 1 ] .. "\"." );
				}
			} else {
				ParserError( "::ParseTextureBlock(). \"group\": wrong amount of arguments (got " .. configFileLine.Size() .. ", must be <name> <x> <y> or <name> <texparam>)." );
			} // of else of if ( configFileLine.Size() == 2 || configFileLine.Size() == 3 ) {}

		} else if ( configFileLine[ 0 ] == "samelinecheck" ) {
			ParserError( "::ParseTextureBlock(). \"samelinecheck\": not released yet." );
		} else if ( configFileLine[ 0 ] == "actionlinecheck" ) {
			ParserError( "::ParseTextureBlock(). \"actionlinecheck\": not released yet." );
		} else {
			ParserError( "::ParseTextureBlock(). Unknown keyword \"" .. configFileLine[ 0 ] .. "\"." );
		}
	} // of void ParseTextureBlock( void ) {}

	void ParseTextureParameterBlock( void ) {
		// Right now percentage are defined as negative float-point digits.
		uint lineArgsAmount = configFileLine.Size();

		if ( configFileLine[ 0 ] == "start" ) {
			if ( lineArgsAmount == 3 )
				parserCurTextureParam.start = ( configFileLine[ 1 ].ToDouble(), configFileLine[ 2 ].ToDouble() );
			else
				ParserError( "::ParseTextureParameterBlock(). \"start\": wrong amout of arguments (got " .. lineArgsAmount .. ", must be <x> <y>)." );
		} else if ( configFileLine[ 0 ] == "offset" ) {
			if ( lineArgsAmount == 3 )
				parserCurTextureParam.offset = ( configFileLine[ 1 ].ToDouble(), configFileLine[ 2 ].ToDouble() );
			else
				ParserError( "::ParseTextureParameterBlock(). \"offset\": wrong amout of arguments (got " .. lineArgsAmount .. ", must be <x> <y>)." );
		} else if ( configFileLine[ 0 ] == "random" ) {
			switch ( lineArgsAmount ) {
				case 2: parserCurTextureParam.spreading.x = parserCurTextureParam.spreading.y = ( configFileLine[ 1 ].ToDouble() );
					break;
				case 3: parserCurTextureParam.spreading = ( configFileLine[ 1 ].ToDouble(), configFileLine[ 2 ].ToDouble() );
					break;
				default: ParserError( "::ParseTextureParameterBlock(). \"random\": wrong amout of arguments (got " .. lineArgsAmount .. ", must be <rndxy> or <rndx> <rndy>)." );
					break;
			}
		} else if ( configFileLine[ 0 ] == "chance" ) {
			if ( lineArgsAmount == 2 )
				parserCurTextureParam.chance = configFileLine[ 1 ].ToDouble();
			else
				ParserError( "::ParseTextureParameterBlock(). \"chance\": wrong amout of arguments (got " .. lineArgsAmount .. ", must be <value>)." );
		}
	} // of void ParseTextureParameterBlock( void ) {}

	void ParseGroupBlock( void ) {
		if ( configFileLine[ 0 ] == "mindistance" ) {
			if ( configFileLine.Size() == 2 )
				parserCurGroup.actorsDistance = configFileLine[ 1 ].ToDouble();
			else
				ParserError( "::ParseGroupBlock(). \"mindistance\": wrong amount of arguments (got " .. configFileLine.Size() .. ", must be <distance>." );

		} else if ( configFileLine[ 0 ] == "soundactor" ) {
			if ( configFileLine.Size() > 1 ) {
				for ( int i = 1; i < configFileLine.Size(); i++ ) {
					AutoAmbientSoundDefinition gsnd = FindSoundDef( configFileLine[ i ] );

					if ( gsnd ) {
						parserCurGroup.AddSoundClass( gsnd );
					} else {
						ParserError( "::ParseGroupBlock(). \"soundactor\": Cannot find class \"" .. configFileLine[ i ] .. "\"." );
						return;
					}
				}
			} else {
				ParserError( "::ParseGroupBlock(). \"soundactor\": no argument(s)." );
			}

		} else if ( configFileLine[ 0 ] == "loopedsound" ) {
			uint lineArgsAmount = configFileLine.Size();

			if ( lineArgsAmount > 1 && lineArgsAmount < 5 ) {
				double newsndvolume = ( lineArgsAmount > 1 )? configFileLine[ 2 ].ToDouble() : 1.0;
				double newsndattn = ( lineArgsAmount == 4 )? configFileLine[ 3 ].ToDouble() : 1.0;

				parserCurGroup.AddAutoLoopedSound( configFileLine[ 1 ], newsndvolume, newsndattn );
			} else {
				ParserError( "::ParseGroupBlock(). \"loopedsound\": wrong amount of arguments (got " .. configFileLine.Size() .. ", must be <snd> [<volume> [<attenuation>]])." );
			} // of else of if ( configFileLine.Size() == 2 || configFileLine.Size() == 3 ) {}

		} else if ( configFileLine[ 0 ] == "actor" ) {
			if ( configFileLine.Size() > 1 ) {
				for ( int i = 1; i < configFileLine.Size() + 1; i++ ) {
					if ( !parserCurGroup.AddClass( configFileLine[ i ] ) ) {
						ParserError( "::ParseGroupBlock(). \"actor\": Cannot find class \"" .. configFileLine[ i ] .. "\"." );
						return;
					}
				}
			} else {
				ParserError( "::ParseGroupBlock(). \"actor\": no argument(s)." );
			}
		} else {
			ParserError( "::ParseGroupBlock(). Unknown keyword \"" .. configFileLine[ 0 ] .. "\"." );
		}
	} // of void ParseGroupBlock( void ) {}

	void ParseSoundActorBlock( void ) {
		if ( configFileLine[ 0 ] == "sound" ) {
			if ( configFileLine.Size() == 2 )
				parserCurSound.snd = configFileLine[ 1 ];
			else
				ParserError( "::ParseSoundActorBlock(). \"sound\": wrong amount of arguments (got " .. configFileLine.Size() .. ", must be <sound>." );

		} else if ( configFileLine[ 0 ] == "mode" ) {
			uint lineArgsAmount = configFileLine.Size();

			if ( lineArgsAmount > 1 ) {
				if ( configFileLine[ 1 ] == "looped" && lineArgsAmount == 2 ) {
					parserCurSound.sndMode = AASM_Looped;
				} else if ( configFileLine[ 1 ] == "fixed" && lineArgsAmount == 3 ) {
					parserCurSound.sndMode = AASM_Fixed;
					parserCurSound.minDelay = configFileLine[ 2 ].ToDouble();
				} else if ( configFileLine[ 1 ] == "random" && lineArgsAmount == 4 ) {
					parserCurSound.sndMode = AASM_Random;
					parserCurSound.minDelay = configFileLine[ 2 ].ToDouble();
					parserCurSound.maxDelay = configFileLine[ 3 ].ToDouble();
				} else {
					ParserError( "::ParseSoundActorBlock(). \"mode\": wrong arguments (must be (looped|fixed <mintics>|random <mintics> <maxtics>)." );
				}
			} else {
				ParserError( "::ParseSoundActorBlock(). \"mode\": wrong amount of arguments (got " .. configFileLine.Size() .. ", must be (looped|fixed <mintics>|random <mintics> <maxtics>)." );
			}

		} else if ( configFileLine[ 0 ] == "volume" ) {
			if ( configFileLine.Size() == 2 )
				parserCurSound.sndVolume = configFileLine[ 1 ].ToDouble();
			else
				ParserError( "::ParseSoundActorBlock(). \"volume\": wrong amount of arguments (got " .. configFileLine.Size() .. ", must be <sound>." );

		} else if ( configFileLine[ 0 ] == "attn" ) {
			if ( configFileLine.Size() == 2 )
				parserCurSound.sndAttenuation = configFileLine[ 1 ].ToDouble();
			else
				ParserError( "::ParseSoundActorBlock(). \"attn\": wrong amount of arguments (got " .. configFileLine.Size() .. ", must be <sound>." );

		} else {
			ParserError( "::ParseSoundActorBlock(). Unknown keyword \"" .. configFileLine[ 0 ] .. "\"." );
		}
	} // of void ParseSoundActorBlock( void ) {}

	void ParseBlockHeader( void ) {
		// Guaranted that amount of words in line is greater than 2.
		// Second case is for using totally default parameters.

		String lastWord = configFileLine[ configFileLine.Size() - 1 ];
		bool emptyBlock = ( lastWord == "{}" || ( configFileLine[ configFileLine.Size() - 2 ] == "{" && lastWord == "}" ) );

		if ( !emptyBlock && lastWord != "{" ) {
			ParserError( "::ParseBlockHeader(). '{' after \"" .. configFileLine[ 1 ] .. "\" expected." ); // '}}' for the not clever colorer.
			return;
		}

		int textureLastNameIndex = configFileLine.Size() - 1;
		if ( lastWord == /*'{'*/ "}" )
			textureLastNameIndex--;

		String blockIdentifier = configFileLine[ 1 ];

		//console.printf( "Identifier: " .. blockIdentifier );

		if ( !emptyBlock && parserCurBlockType != AAPB_Texture )
			readNextConfigLine();

		switch ( parserCurBlockType ) {
			case AAPB_Texture:
				// Different handling because of not fixed amount of arguments.

				Array<String> textureNames;
				for ( int i = 1; i < textureLastNameIndex; i++ )
					textureNames.Push( configFileLine[ i ] );

				parserCurTexture = AutoAmbientTexture.CreateTemporalBase();
				parserCurTexture.actionlineCheck = parserDefaultTexture.actionlineCheck;
				parserCurTexture.samelineCheck = parserDefaultTexture.samelineCheck;

				if ( !emptyBlock ) {
					readNextConfigLine();
					while ( !parserErrorFlag && ( !configFileLine.Size() ^ ( configFileLine[ 0 ] != /*'{'*/ "}" ) ) ) {
						ParseTextureBlock();
						readNextConfigLine();
					}
				} else {
					for ( int i = 0; i < parserDefaultTexture.groups.Size(); i++ )
						parserCurTexture.AddGroupParam( parserDefaultTexture.groups[ i ], parserDefaultTexture.groupparams[ i ] );

					parserCurTexture.actionlineCheck = parserDefaultTexture.actionlineCheck;
					parserCurTexture.samelineCheck = parserDefaultTexture.samelineCheck;
				} // of else, of if ( !emptyBlock ) {}

				for ( int i = 0; i < textureNames.Size(); i++ ) {
					String curIdentifier = textureNames[ i ];
					AutoAmbientTexture newTextureDef;

					if ( curIdentifier == "default" ) {
						newTextureDef = parserDefaultTexture;
						newTextureDef.groups.Clear();
						newTextureDef.groupparams.Clear();
					} else {
						newTextureDef = AutoAmbientTexture.Create( curIdentifier );

						if ( !newTextureDef ) {
							ParserError( "::ParseBlockHeader(). \"texture\": Wrong texture name \"" .. curIdentifier .. "\"." );
							break;
						}
					}

					if ( newTextureDef ) {
						for ( int i = 0; i < parserCurTexture.groups.Size(); i++ )
							newTextureDef.AddGroupParam( parserCurTexture.groups[ i ], parserCurTexture.groupparams[ i ].Copy() );

						newTextureDef.actionlineCheck = parserCurTexture.actionlineCheck;
						newTextureDef.samelineCheck = parserCurTexture.samelineCheck;

						if ( newTextureDef != parserDefaultTexture ) {
							//console.printf( "Push to textures[]: " .. parserCurTexture.id );
							textures.Push( newTextureDef );
						}
					} // of if ( parserCurTexture ) {}

				} // of for ( int i = 0; i < textureNames.Size(); i++ ) {}
				break;
			case AAPB_TextureParameter:
				if ( blockIdentifier == "default" )
					parserCurTextureParam = parserDefaultTextureParam;
				else
					parserCurTextureParam = AutoAmbientTextureParameter.Create( blockIdentifier, parserDefaultTextureParam.start, parserDefaultTextureParam.offset, parserDefaultTextureParam.spreading, parserDefaultTextureParam.chance );

				if ( !emptyBlock )
					while ( !parserErrorFlag && ( !configFileLine.Size() ^ ( configFileLine[ 0 ] != /*'{'*/ "}" ) ) ) {
						ParseTextureParameterBlock();
						readNextConfigLine();
					}

				if ( parserCurTextureParam && parserCurTextureParam != parserDefaultTextureParam )
					textureparams.Push( parserCurTextureParam );
				break;
			case AAPB_Group:
				if ( blockIdentifier == "default" ) {
					parserCurGroup = parserDefaultGroup;
					parserCurGroup.classes.Clear();
					parserCurGroup.autoclasses.Clear();
				} else {
					parserCurGroup = AutoAmbientGroup.Create( blockIdentifier, parserDefaultGroup.actorsDistance );
				}

				if ( !emptyBlock )
					while ( !parserErrorFlag && ( !configFileLine.Size() ^ ( configFileLine[ 0 ] != /*'{'*/ "}" ) ) ) {
						ParseGroupBlock();
						readNextConfigLine();
					}

				if ( parserCurGroup && parserCurGroup != parserDefaultGroup )
					groups.Push( parserCurGroup );
				break;
			case AAPB_SoundDef:
				if ( blockIdentifier == "default" ) {
					parserCurSound = parserDefaultSound;
				} else {
					parserCurSound = AutoAmbientSoundDefinition.Create( blockIdentifier, "null",
							parserDefaultSound.sndMode, parserDefaultSound.sndVolume, parserDefaultSound.sndAttenuation,
							parserDefaultSound.minDelay, parserDefaultSound.maxDelay );
				}

				if ( !emptyBlock )
					while ( !parserErrorFlag && ( !configFileLine.Size() ^ ( configFileLine[ 0 ] != /*'{'*/ "}" ) ) ) {
						ParseSoundActorBlock();
						readNextConfigLine();
					}

				if ( parserCurSound && parserCurSound != parserDefaultSound )
					sounddefs.Push( parserCurSound );
				break;
			case AAPB_Global:
				ParserError( "::ParseBlockHeader(). Impossible parser block type \"Global\"." );
				break;
			default:
				ParserError( "::ParseBlockHeader(). Unrecognized parser block type " .. parserCurBlockType .. "." );
				break;
		}

	} // of void ParseBlockHeader( void ) {}

	void ParseGlobalScope( void ) {
		//String curWord = readNextWord();
		readNextConfigLine();
		//console.printf( GetClassName() .. "::ParseGlobalScope(). Parsed line \"" .. curWord .. "\"." );

		uint lineArgsAmount = configFileLine.Size();

		if ( lineArgsAmount > 0 ) {
			if ( lineArgsAmount == 2 && configFileLine[ 0 ] == "include" ) {
				int prevParserLineNum = parserLineNum;
				String prevConfigFile = aaConfigFile;

				parserLineNum = 0;
				ParseFile( configFileLine[ 1 ] );

				aaConfigFile = prevConfigFile;
				parserCurBlockType = AAPB_Global;
				parserLineNum = prevParserLineNum;
			} else if ( configFileLine[ 0 ] == "texture" ) {
				if ( lineArgsAmount > 2 ) {
					parserCurBlockType = AAPB_Texture;
					ParseBlockHeader();
				} else {
					ParserError( "::ParseGlobalScope(). Amount of words after the texture block definition must be greater than 1." );
				}
			} else if ( lineArgsAmount == 3 ) {
				if ( configFileLine[ 0 ] == "textureparam" )
					parserCurBlockType = AAPB_TextureParam;
				else if ( configFileLine[ 0 ] == "group" )
					parserCurBlockType = AAPB_Group;
				else if ( configFileLine[ 0 ] == "soundactor" )
					parserCurBlockType = AAPB_SoundDef;
				else
					ParserError( "::ParseGlobalScope(). Unknown global scope keyword \"" .. configFileLine[ 0 ] .. "\"." );

				if ( parserCurBlockType != AAPB_Global )
					ParseBlockHeader();
			} else {
				ParserError( "::ParseGlobalScope(). Incorrect global scope keyword sequence (\"" .. configFileLine[ 0 ] .. " <...>\")." );
			}
		} // of if ( lineArgsAmount > 0 ) {
	} // of void ParseGlobalScope( void ) {}


	void ParseFile( String filename ) {
		int configFileHandler = Wads.FindLump( filename );

		// "AAmbient.cfg" file unparsing:
        if ( configFileHandler != -1 ) {
			console.printf( GetClassName() .. "::ParseFile(). Parsing file \"" .. filename .. "\"." );
			//parserPos = 0;
			parserLineNum = 0;
            aaConfigFile = Wads.ReadLump( configFileHandler );

            aaConfigFile.ToLower();
            aaConfigFile.Replace( "\r", "\n" ); // "dos2unix", "mac2unix"...
			//aaConfigFileLength = aaConfigFile.Length();
            aaConfigFile.Split( aaConfigLines, "\n", TOK_SKIPEMPTY );

			while ( parserLineNum < aaConfigLines.Size() && !parserErrorFlag ) {
				parserCurBlockType = AAPB_Global;
				ParseGlobalScope();
			}

        } else {
			ParserError( "::ParseFile(). Cannot find file \"" .. filename .. "\"." );
		}
	} // of void ParseFile( String filename ) {}

	// Configuration init/file parser:
	override void OnRegister() {
		SetOrder( AutoAmbientHandlerOrder );

		//lastGroupIndex = -1;
		textures.Clear();
		groups.Clear(); 
		textureparams.Clear();
		sounddefs.Clear();

		texcache.Clear();

		/*lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Pipe", 256 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Pipes", vol: 0.4, attn: 4.5 );
		AddTexture( "BROWNPIP" );
		AddTexture( "METAL4" );
		AddTexture( "PIPE2" );
		AddTexture( "PIPE6" );
		AddTexture( "PIPEWAL1" );
		AddTexture( "PIPES" );
		AddTexture( "SW1PIPE" );
		AddTexture( "SW2PIPE" );
		AddTexture( "TEKGREN4" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Comp", 128 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Computers/Beep", AASM_Fixed, 0.4, 5.0, 35 );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Computers/Boop", AASM_Fixed, 0.4, 5.0, 35 );
		//groups[ lastGroupIndex ].AddClass( "AutoAmbientActor_Comp" );
		AddTexture( "COMPSTA1" );
		AddTexture( "COMPSTA2" );
		AddTexture( "COMPTALL", start: ( 32.0, 64.0 ), offset: ( 96.0, 0.0 ) );
		AddTexture( "SILVER3" );
		AddTexture( "SPACEW3", ( 32.0, 32.0 ), ( 64.0, 64.0 ), ( 0.0, 24.0 ) );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Tech", 192 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Tech", vol: 0.7, attn: 3.5 );
		AddTexture( "CEMENT2" );
		AddTexture( "CEMENT4" );
		AddTexture( "ICKWALL4" );
		AddTexture( "SW1COMP" );
		AddTexture( "SW2COMP" );
		AddTexture( "COMPTALL" );
		AddTexture( "COMPWERD" );
		AddTexture( "TEKGREN1" );
		AddTexture( "TEKWALL1" );
		AddTexture( "TEKWALL4" );
		AddTexture( "TEKWALL6" );
		AddTexture( "ZZZFACE6" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "BloodPipe", 96 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/BloodPipes", vol: 0.6, attn: 4.2 );
		AddTexture( "BLODRIP1" );
		AddTexture( "BLODRIP2" );
		AddTexture( "BLODRIP3" );
		AddTexture( "BLODRIP4" );
		AddTexture( "PIPE1" );
		AddTexture( "SK_LEFT" );
		AddTexture( "SK_RIGHT" );
		AddTexture( "SLOPPY2" );*/

		parserDefaultTexture = AutoAmbientTexture.CreateTemporalBase();
		parserDefaultTextureParam = AutoAmbientTextureParameter.Create( "Default texture parameter", ( -50.0, -50.0 ), ( -100.0, -100.0 ), ( 0.0, 0.0 ), 1.0 );
		parserDefaultGroup = AutoAmbientGroup.Create( "Default group", 256 );
		parserDefaultSound = AutoAmbientSoundDefinition.Create( "Default sound definition", "null", AASM_Looped, 1.0, 1.0, 35, 35 );

		parserCurTexture = NULL;
		parserCurTextureParam = NULL;
		parserCurGroup = NULL;
		parserCurSound = NULL;

		ParseFile( "aambient.cfg" );
		if ( !parserErrorFlag )
			console.printf( GetClassName() .. "::OnRegister(). Loading configuration done." );
		else
			console.printf( GetClassName() .. "::OnRegister(). An error occured in line " .. parserLineNum .. " during configuration file parsing." );

		Super.OnRegister();
	}


	override void WorldLoaded( WorldEvent e ) {
		bool dontLoadAutoAmbient = false;

		if ( e.IsSaveGame || parserErrorFlag )
			dontLoadAutoAmbient = true;

		AutoAmbientTexture invalidTexture = FindInvalidTexture();

		if ( invalidTexture ) {
			dontLoadAutoAmbient = true;
			console.printf( GetClassName() .. "::WorldLoaded(). ERROR: texture definition ID " .. invalidTexture.id .. " is not valid." );
			console.printf( GetClassName() .. "::WorldLoaded(). Validate callback: " 
							.. "id=" .. TexMan.GetName( invalidTexture.id ) .. ", size.Length()=" .. invalidTexture.size.Length() 
							.. ", groups.Size()=" .. invalidTexture.groups.Size() .. ", groupparams.Size()=" .. !invalidTexture.groupparams.Size() 
							.. ", addingErrorFlag=" .. invalidTexture.invalidFlag );
		}


		if ( dontLoadAutoAmbient ) {
			Super.WorldLoaded( e );
			return;
		}

		// Static event handler may save information through levels.
		for ( int i = 0; i < groups.Size(); i++ )
			groups[ i ].ClearSpawned();


		// A-a-argh! Seven nested "for" cycles in worst case!..
		//(Alright, it's non-exponential dependence, most of them has from one 
		//to three iterations).
		for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {
			Side l = level.Sides[ curSideIndex ];

			for ( int curSidePos = 0; curSidePos < 2; curSidePos++ ) {
				TextureID texID = l.GetTexture( curSidePos );

				if ( texID ) {
					//console.printf( "Texture \"" .. TexMan.GetName( texID ) .. "\"." );
					AutoAmbientCacheTexture cachedTexture = NULL;

					// Here must be a use frequency list, really.

					// Attempt to find texture in cache array:
					for ( int j = 0; j < texcache.Size(); j++ ) {
						if ( texcache[ j ].texID == texID ) {
							cachedTexture = texcache[ j ];
							texcache[ j ].frequency++;

							// Ordering by use frequency:
							/*if ( j > 0 && groupcache[ j ].frequency > groupcache[ j - 1 ].frequency ) {
								// Really slow executing caused by universality.
								//Moreover, lines below will swap only neighbour
								//elements ("2, 1, 1, 2" -> "2, 1, 2, 1").
								groupcache.Insert( j - 1, groupcache[ j ] );
								groupcache.Delete( j + 1, 1 );
							} */
							break;
						}
					} // of for ( int j = 0; j < groupcache.Size(); j++ ) {}

					// Creating new texture cache if necessary:
					if ( !cachedTexture ) {
						cachedTexture = new( 'AutoAmbientCacheTexture' );
						cachedTexture.texID = texID;
						cachedTexture.frequency = 1;
						cachedTexture.texdef = NULL; // Texture may has no defined ambient actors.

						for ( int j = 0; j < textures.Size(); j++ )
							if ( textures[ j ].id == texID ) {
								cachedTexture.texdef = textures[ j ];
								break;
							}

						texcache.Push( cachedTexture );
					}

					// Spawning actor(s) according to the cached groups:
					AutoAmbientTexture curtexdef = cachedTexture.texdef;

					if ( curtexdef ) {
						for ( int j = 0; j < curtexdef.groups.Size(); j++ )
							curtexdef.groups[ j ].SpawnActor( l, curSidePos, curtexdef, j );
					}

				} // of if ( texID ) {}

			} // of for ( int curSidePos = 0; curSidePos < 2; curSidePos++ ) {}

		} // of for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {}


		Super.WorldLoaded( e );
	} // of override void WorldLoaded( WorldEvent e ) {}

} // of class AmbientHandler: EventHandler {}
