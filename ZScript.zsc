version "2.4.0"

#include "ZScript/AutoAmbientCore/Constants.zsc"
#include "ZScript/AutoAmbientCore/Utils.zsc"

#include "ZScript/AutoAmbientCore/DListTexCache.zsc"
#include "ZScript/AutoAmbientCore/SListSpawned.zsc"

#include "ZScript/AutoAmbientCore/DataClasses.zsc"
#include "ZScript/AutoAmbientCore/AutoActors.zsc"
#include "ZScript/AutoAmbientCore/ConfigParser.zsc"



class AutoAmbientGlobalHandler: StaticEventHandler {
	const AutoAmbientHandlerOrder = 0x7FAA0004; // ZChecker: 0x7FAA0005 and 0x7FAA0006.

	const replicateParserMaxAmount = 16;
	int replicateParserAmount; // To prevent infinite recursive including loop.
	int parserErrorLine;
	String parserErrorFilename;

	Array<AutoAmbientTexture> textures;
	Array<AutoAmbientGroup> groups;
	Array<AutoAmbientTextureParameter> textureparams;
	Array<AutoAmbientSoundDefinition> sounddefs;

	// Dangerous function, actually...
	static AutoAmbientGlobalHandler Get( void ) {
		return AutoAmbientGlobalHandler( StaticEventHandler.Find( "AutoAmbientGlobalHandler" ) );
	}


	bool DescendIncludeFileLevel( void ) {
		bool outValue = false;

		if ( replicateParserAmount < replicateParserMaxAmount ) {
			replicateParserAmount++;
			outValue = true;
		}

		return outValue;
	}

	void AscendIncludeFileLevel( void ) {
		if ( replicateParserAmount > 0 )
			replicateParserAmount--;
		else
			AutoAmbientLogger.Get().Log( LL_Emergency, GetClassName() .. "AscendIncludeFileLevel(). Tried to ascend over the first level." );
	}

	String GetFormattedIncludeFileLevel( void ) {
		return TEXTCOLOR_GRAY .. ( ( replicateParserAmount == 0 )? "top" : "nested level " .. replicateParserAmount .. "\c-" );
	}

	AutoAmbientTexture FindInvalidTexture( void ) {
		for ( int i = 0; i < textures.Size(); i++ )
			if ( !textures[ i ].Validate() )
				return textures[ i ];

		return NULL;
	}


	// Configuration init and file parsing:
	override void OnRegister() {
		AutoAmbientLogger logger = AutoAmbientLogger.Get();
		SetOrder( AutoAmbientHandlerOrder );

		textures.Clear();
		groups.Clear(); 
		textureparams.Clear();
		sounddefs.Clear();

		/*lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Pipe", 256 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Pipes", vol: 0.4, attn: 4.5 );
		AddTexture( "BROWNPIP" );
		AddTexture( "METAL4" );
		AddTexture( "PIPE2" );
		AddTexture( "PIPE6" );
		AddTexture( "PIPEWAL1" );
		AddTexture( "PIPES" );
		AddTexture( "SW1PIPE" );
		AddTexture( "SW2PIPE" );
		AddTexture( "TEKGREN4" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Comp", 128 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Computers/Beep", AASM_Fixed, 0.4, 5.0, 35 );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Computers/Boop", AASM_Fixed, 0.4, 5.0, 35 );
		//groups[ lastGroupIndex ].AddClass( "AutoAmbientActor_Comp" );
		AddTexture( "COMPSTA1" );
		AddTexture( "COMPSTA2" );
		AddTexture( "COMPTALL", start: ( 32.0, 64.0 ), offset: ( 96.0, 0.0 ) );
		AddTexture( "SILVER3" );
		AddTexture( "SPACEW3", ( 32.0, 32.0 ), ( 64.0, 64.0 ), ( 0.0, 24.0 ) );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "Tech", 192 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/Tech", vol: 0.7, attn: 3.5 );
		AddTexture( "CEMENT2" );
		AddTexture( "CEMENT4" );
		AddTexture( "ICKWALL4" );
		AddTexture( "SW1COMP" );
		AddTexture( "SW2COMP" );
		AddTexture( "COMPTALL" );
		AddTexture( "COMPWERD" );
		AddTexture( "TEKGREN1" );
		AddTexture( "TEKWALL1" );
		AddTexture( "TEKWALL4" );
		AddTexture( "TEKWALL6" );
		AddTexture( "ZZZFACE6" );

		lastGroupIndex = groups.Push( AutoAmbientGroup.Create( "BloodPipe", 96 ) );
		groups[ lastGroupIndex ].AddAutoSoundClass( "AA/BloodPipes", vol: 0.6, attn: 4.2 );
		AddTexture( "BLODRIP1" );
		AddTexture( "BLODRIP2" );
		AddTexture( "BLODRIP3" );
		AddTexture( "BLODRIP4" );
		AddTexture( "PIPE1" );
		AddTexture( "SK_LEFT" );
		AddTexture( "SK_RIGHT" );
		AddTexture( "SLOPPY2" );*/

		AutoAmbientConfigParser.Create( self ).ParseFile( "aambient.cfg" );


		if ( !parserErrorLine )
			logger.Log( LL_Main | LL_NoPrefix, GetClassName() .. "::OnRegister(). Loading configuration done." );
		else
			logger.Log( LL_Emergency, GetClassName() .. "::OnRegister(). Error during configuration files parsing in " .. parserErrorFilename .. " on line " .. parserErrorLine .. "." );


		if ( logger.aaCurLogLevel >= LL_Debug ) {
			// You cannot call a function with an Array<> argument type in some
			//old versions of the engine.
			logger.Log( LL_Debug, TEXTCOLOR_SAPPHIRE .. GetClassName() .. "::OnRegister(). Sound definitions (total " .. sounddefs.Size() .. ")" .. logger.LLCOLOR_DEBUG .. ":" );
			for ( int i = 0; i < sounddefs.Size(); i++ ) {
				if ( sounddefs[ i ] )
					logger.Log( LL_Debug, "SND #" .. i .. " \"" .. sounddefs[ i ].name .. "\": snd " .. sounddefs[ i ].snd .. " vol " .. sounddefs[ i ].sndVolume .. " attn " .. sounddefs[ i ].sndAttenuation .. ", mode " .. sounddefs[ i ].sndMode .. " " .. sounddefs[ i ].minDelay .. " " .. sounddefs[ i ].maxDelay );
				else
					logger.Log( LL_Debug, "SND #" .. i .. ": NULL!!!" );
			} // of for ( int i = 0; i < sounddefs.Size(); i++ ) {}

			logger.Log( LL_Debug, TEXTCOLOR_SAPPHIRE .. GetClassName() .. "::OnRegister(). Texture parameters (total " .. textureparams.Size() .. ")" .. logger.LLCOLOR_DEBUG .. ":" );
			for ( int i = 0; i < textureparams.Size(); i++ ) {
				if ( textureparams[ i ] )
					logger.Log( LL_Debug, "TPM #" .. i .. " \"" .. textureparams[ i ].name .. "\": " .. textureparams[ i ].start .. "++" .. textureparams[ i ].offset .. " rnd " .. textureparams[ i ].spreading .. " chnc " .. textureparams[ i ].chance );
				else
					logger.Log( LL_Debug, "TPM #" .. i .. ": NULL!!!" );
			} // of for ( int i = 0; i < textureparams.Size(); i++ ) {}

			logger.Log( LL_Debug, TEXTCOLOR_SAPPHIRE .. GetClassName() .. "::OnRegister(). Groups (total " .. groups.Size() .. ")" .. logger.LLCOLOR_DEBUG .. ":" );
			for ( int i = 0; i < groups.Size(); i++ ) {
				AutoAmbientGroup curgroup = groups[ i ];

				if ( curgroup ) {
					logger.Log( LL_Debug, "GRP #" .. i .. " \"" .. curgroup.name .. "\": mindist " .. curgroup.actorsDistance .. ", &spawned: " .. curgroup.spawned .. ", &spawnedOnLine: " .. curgroup.spawnedOnLine .. ", classes:" );
					String debugStr = "";

					for ( int j = 0; j < curgroup.classes.Size(); j++ ) {
						debugStr = debugStr .. " (" .. TEXTCOLOR_GRAY;

						if ( !curgroup.classes[ j ] )
							debugStr = debugStr .. " (" .. logger.LLCOLOR_EMERGENCY .. "Class #" .. j .. " is NULL!";
						else
							debugStr = debugStr .. curgroup.classes[ j ].GetClassName();

						debugStr = debugStr .. logger.LLCOLOR_DEBUG .. ")";
					}

					for ( int j = 0; j < curgroup.autoclasses.Size(); j++ ) {
						debugStr = debugStr .. " (" .. TEXTCOLOR_GRAY;

						if ( !curgroup.autoclasses[ j ] )
							debugStr = debugStr .. " (" .. logger.LLCOLOR_EMERGENCY .. "Autoclass #" .. j .. " is NULL!";
						else
							debugStr = debugStr .. "Auto:" .. curgroup.autoclasses[ j ].name;

						debugStr = debugStr .. logger.LLCOLOR_DEBUG .. ")";
					}

					if ( debugStr == "" )
						debugStr = TEXTCOLOR_YELLOW .. " No classes defined";

					logger.Log( LL_Debug, " \\_" .. debugStr );
				} else {
					logger.Log( LL_Debug, "GRP #" .. i .. ": NULL!!!" );
				}
			} // of for ( int i = 0; i < groups.Size(); i++ ) {}

			logger.Log( LL_Debug, TEXTCOLOR_SAPPHIRE .. GetClassName() .. "::OnRegister(). Textures (total " .. textures.Size() .. ")" .. logger.LLCOLOR_DEBUG .. ":" );
			for ( int i = 0; i < textures.Size(); i++ ) {
				AutoAmbientTexture curtex = textures[ i ];

				if ( curtex ) {
					logger.Log( LL_Debug, "TEX #" .. i .. " \"" .. curtex.id .. "\": size " .. curtex.size .. ", flags " .. curtex.linesCheckFlags .. ", spawnchances same:" .. curtex.sameLineDistSpawnChance .. " other:" .. curtex.otherLineDistSpawnChance .. ", groups:" );
					String debugStr = "";

					for ( int j = 0; j < curtex.groups.Size(); j++ ) {
						debugStr = debugStr .. " (" .. TEXTCOLOR_GRAY;

						if ( !curtex.groups[ j ] )
							debugStr = debugStr .. logger.LLCOLOR_EMERGENCY .. "Group #" .. j .. " is NULL!";
						else if ( !curtex.groupparams[ j ] )
							debugStr = debugStr .. logger.LLCOLOR_EMERGENCY .. "Group \"" .. curtex.groups[ j ].name .. "\" (#" .. j .. ")'s texparam is NULL!!!";
						else
							debugStr = debugStr .. curtex.groups[ j ].name .. " at " .. curtex.groupparams[ j ].name;

						debugStr = debugStr .. logger.LLCOLOR_DEBUG .. ")";
					}

					if ( debugStr == "" )
						debugStr = TEXTCOLOR_YELLOW .. " No groups defined";

					logger.Log( LL_Debug, " \\_" .. debugStr );
				} else {
					logger.Log( LL_Debug, "TEX #" .. i .. ": NULL!!!" );
				}
			} // of for ( int i = 0; i < textures.Size(); i++ ) {}

		} // of if ( logger.aaCurLogLevel >= LL_Debug ) {}


		Super.OnRegister();
	} // of override void OnRegister() {}


	override void WorldLoaded( WorldEvent e ) {
		bool dontLoadAutoAmbient = false;
		AutoAmbientLogger logger = AutoAmbientLogger.Get();

		// Some checks which prevents second large part from loading:
		if ( e.IsSaveGame || ( parserErrorLine != 0 ) ) {
			dontLoadAutoAmbient = true;
		} else if ( !groups.Size() ) {
			logger.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). No group blocks provided in the configuration file." );
			dontLoadAutoAmbient = true;
		} else if ( !textures.Size() ) {
			logger.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). No texture definition blocks provided in the configuration file." );
			dontLoadAutoAmbient = true;
		} else {
			AutoAmbientTexture invalidTexture = FindInvalidTexture();

			if ( invalidTexture ) {
				dontLoadAutoAmbient = true;
				logger.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). Texture definition ID " .. invalidTexture.id .. " is not valid." );
				logger.Log( LL_Main, GetClassName() .. "::WorldLoaded(). Validate callback: " 
								.. "id=" .. TexMan.GetName( invalidTexture.id ) .. ", size.Length()=" .. invalidTexture.size.Length() 
								.. ", groups.Size()=" .. invalidTexture.groups.Size() .. ", groupparams.Size()=" .. invalidTexture.groupparams.Size() 
								.. ", addingErrorFlag=" .. invalidTexture.invalidFlag );
			}
		}

		if ( dontLoadAutoAmbient ) {
			Super.WorldLoaded( e );
			return;
		}

		// Static event handler may save information through levels.
		for ( int i = 0; i < groups.Size(); i++ )
			groups[ i ].ClearSpawned();


		AutoAmbientCacheTextureKeeper cachedTextures = AutoAmbientCacheTextureKeeper.CreateKeeper( self );

		int totalAutoAmbientActorsSpawned = 0;

		// A-a-argh! Seven nested "for" cycles in worst case!..
		//(Alright, it's non-exponential dependence, most of them has from one 
		//to three iterations).

		// All sides cycle:
		for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {
			Side l = level.Sides[ curSideIndex ];

			// Top/middle/bottom texture on line cycle:
			for ( int curSidePos = Side.top; curSidePos <= Side.bottom; curSidePos++ ) {
				TextureID texID = l.GetTexture( curSidePos );

				if ( texID ) {
					// Finding texture in cache array or creating it there:
					AutoAmbientCacheTexture cachedTexture = cachedTextures.Update( texID );

					// Spawning actor(s) according to the cached groups:
					AutoAmbientTexture curtexdef = cachedTexture.texdef;
					if ( curtexdef ) {
						// Storing actors spawned on one line to flush them at
						//once later. May look illogical, but it saves about
						//2-13% of time (see Doom 2 MAP24).
						Array<AutoAmbientGroup> uniqueGroups;

						for ( int j = 0; j < curtexdef.groups.Size(); j++ ) {
							AutoAmbientGroup curGroup = curtexdef.groups[ j ];

							totalAutoAmbientActorsSpawned += curGroup.SpawnActor( l, curSidePos, curtexdef, j );

							bool uniqueGroupFlag = true;
							for ( int k = 0; k < uniqueGroups.Size(); k++ ) {
								if ( curGroup == uniqueGroups[ k ] ) {
									uniqueGroupFlag = false;
									break;
								}
							}

							if ( uniqueGroupFlag )
								uniqueGroups.Push( curGroup );
						}

						// Move all actors spawned on line to the general array:
						for ( int j = 0; j < uniqueGroups.Size(); j++ )
							uniqueGroups[ j ].FlushSpawnLineActors();

					} // of if ( curtexdef ) {}

				} // of if ( texID ) {}

			} // of for ( int curSidePos = 0; curSidePos < 2; curSidePos++ ) {}

		} // of for ( int curSideIndex = 0; curSideIndex < level.Sides.Size(); curSideIndex++ ) {}

		logger.Log( LL_Detailed, GetClassName() .. "::WorldLoaded(). Total ambient actors spawned: " .. totalAutoAmbientActorsSpawned .. "." );


		if ( logger.aaCurLogLevel >= LL_Debug ) {
			logger.Log( LL_Debug, "AutoAmbientCacheTextureKeeper. Head " .. cachedTextures.head .. " <<->> tail " .. cachedTextures.tail .. "." );
			AutoAmbientCacheTexture debugTexCache = cachedTextures.head;
			uint debugTotalTexCacheAmount = 0;

			while ( debugTexCache ) {
				String debugTexCacheName = String.Format( "%8s", TexMan.GetName( debugTexCache.texID ) );
				logger.Log( LL_Debug, "|- Texture " .. debugTexCacheName .. " freq " .. debugTexCache.frequency .. ": (" .. debugTexCache.prev .. ")<p " .. debugTexCache .. " n>(" .. debugTexCache.next .. ")" );
				debugTexCache = debugTexCache.next;
				debugTotalTexCacheAmount++;
			}

			logger.Log( LL_Debug, "AutoAmbientCacheTextureKeeper. Total texture cache nodes amount: " .. debugTotalTexCacheAmount .. "." );
		}


		CVar optionCVar = CVar.GetCVar( "mcm_aambient_showactorsatstart" );

		if ( optionCVar && optionCVar.GetBool() )
			EventHandler.SendNetworkEvent( "mcm_autoambient_actors_visibility", 1 );

		// Yes, I know perfectly well that garbage collector will successfully 
		//destroy an array.
		cachedTextures.Clear();

		Super.WorldLoaded( e );
	} // of override void WorldLoaded( WorldEvent e ) {}


	override void NetworkProcess( ConsoleEvent e ) {
		if ( e.name == "mcm_autoambient_actors_visibility" ) {
			bool setInvisibleFlag = ( e.args[ 0 ] == 0 );

			for ( int i = 0; i < groups.Size(); i++ ) {
				AutoAmbientListSpawnedKeeper spawnedKeeper = groups[ i ].spawned;
				Actor curspawned = spawnedKeeper.ActorIteratorBegin();

				while ( curspawned ) {
					curspawned.bINVISIBLE = setInvisibleFlag;
					curspawned = spawnedKeeper.ActorIteratorNext();
				}
			} // of for ( int i = 0; i < groups.Size(); i++ ) {}

			AutoAmbientLogger.Get().Log( LL_Detailed, "Changed automatic actors visibility to " .. !setInvisibleFlag );
		} // of if ( e.name == "mcm_autoambient_actors_visibility" ) {}

		Super.NetworkProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {}

} // of class AmbientHandler: EventHandler {}
